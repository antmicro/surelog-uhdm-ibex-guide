diff --git a/Makefile b/Makefile
index 84ec551c6..879b69445 100644
--- a/Makefile
+++ b/Makefile
@@ -587,6 +587,7 @@ $(eval $(call add_include_file,libs/json11/json11.hpp))
 $(eval $(call add_include_file,passes/fsm/fsmdata.h))
 $(eval $(call add_include_file,frontends/ast/ast.h))
 $(eval $(call add_include_file,frontends/ast/ast_binding.h))
+$(eval $(call add_include_file,frontends/verilog/verilog_frontend.h))
 $(eval $(call add_include_file,frontends/blif/blifparse.h))
 $(eval $(call add_include_file,backends/rtlil/rtlil_backend.h))
 $(eval $(call add_include_file,backends/cxxrtl/cxxrtl.h))
diff --git a/frontends/ast/ast.cc b/frontends/ast/ast.cc
index 4fbc238b0..f507abbb8 100644
--- a/frontends/ast/ast.cc
+++ b/frontends/ast/ast.cc
@@ -178,6 +178,7 @@ std::string AST::type2str(AstNodeType type)
 	X(AST_UNION)
 	X(AST_STRUCT_ITEM)
 	X(AST_BIND)
+	X(AST_INSIDE)
 #undef X
 	default:
 		log_abort();
@@ -214,6 +215,7 @@ AstNode::AstNode(AstNodeType type, AstNode *child1, AstNode *child2, AstNode *ch
 	is_signed = false;
 	is_string = false;
 	is_enum = false;
+	is_packed = false;
 	is_wand = false;
 	is_wor = false;
 	is_unsized = false;
@@ -275,12 +277,38 @@ void AstNode::delete_children()
 	attributes.clear();
 }
 
+AstNode* AstNode::find_child(const std::string& name)
+{
+	for (auto child : children) {
+		if (child->str == name) {
+			return child;
+		}
+	}
+	return nullptr;
+}
+
+AstNode* AstNode::find_child(AstNodeType type, const std::string& name)
+{
+	auto child = find_child(name);
+	if (child && child->type == type) {
+		return child;
+	}
+	return nullptr;
+}
+
 // AstNode destructor
 AstNode::~AstNode()
 {
 	delete_children();
 }
 
+void AstNode::visitEachDescendant(const std::function<void(AST::AstNode*)>& f) {
+	for (auto child : children) {
+		f(child);
+		child->visitEachDescendant(f);
+	}
+}
+
 // create a nice text representation of the node
 // (traverse tree by recursion, use 'other' pointer for diffing two AST trees)
 void AstNode::dumpAst(FILE *f, std::string indent) const
@@ -351,6 +379,9 @@ void AstNode::dumpAst(FILE *f, std::string indent) const
 	if (is_enum) {
 		fprintf(f, " type=enum");
 	}
+	if (is_packed) {
+		fprintf(f, " packed");
+	}
 	fprintf(f, "\n");
 
 	for (auto &it : attributes) {
@@ -766,6 +797,14 @@ AstNode *AstNode::mkconst_int(uint32_t v, bool is_signed, int width)
 	return node;
 }
 
+// create an AST node for a real constant
+AstNode *AstNode::mkconst_real(double v)
+{
+	AstNode *node = new AstNode(AST_REALVALUE);
+	node->realvalue = v;
+	return node;
+}
+
 // create an AST node for a constant (using a bit vector as value)
 AstNode *AstNode::mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsized)
 {
@@ -1364,15 +1403,6 @@ std::pair<std::string,std::string> AST::split_modport_from_type(std::string name
 
 }
 
-AstNode * AST::find_modport(AstNode *intf, std::string name)
-{
-	for (auto &ch : intf->children)
-		if (ch->type == AST_MODPORT)
-			if (ch->str == name) // Modport found
-				return ch;
-	return NULL;
-}
-
 // Iterate over all wires in an interface and add them as wires in the AST module:
 void AST::explode_interface_port(AstNode *module_ast, RTLIL::Module * intfmodule, std::string intfname, AstNode *modport)
 {
@@ -1460,9 +1490,8 @@ void AstModule::reprocess_module(RTLIL::Design *design, const dict<RTLIL::IdStri
 							RTLIL::Module *intfmodule = design->module(interface_type); // All interfaces should at this point in time (assuming
 							                                                              // reprocess_module is called from the hierarchy pass) be
 							                                                              // present in design->modules_
-							AstModule *ast_module_of_interface = (AstModule*)intfmodule;
 							std::string interface_modport_compare_str = "\\" + interface_modport;
-							AstNode *modport = find_modport(ast_module_of_interface->ast, interface_modport_compare_str); // modport == NULL if no modport
+							AstNode *modport = ast->find_child(AST::AST_MODPORT, interface_modport_compare_str); // modport == NULL if no modport
 							// Iterate over all wires in the interface and add them to the module:
 							explode_interface_port(new_ast, intfmodule, name_port, modport);
 						}
@@ -1538,7 +1567,7 @@ RTLIL::IdString AstModule::derive(RTLIL::Design *design, const dict<RTLIL::IdStr
 				std::string interface_modport = modports.at(intfname).str();
 				AstModule *ast_module_of_interface = (AstModule*)intfmodule;
 				AstNode *ast_node_of_interface = ast_module_of_interface->ast;
-				modport = find_modport(ast_node_of_interface, interface_modport);
+				modport = ast_node_of_interface->find_child(AST::AST_MODPORT, interface_modport);
 			}
 			// Iterate over all wires in the interface and add them to the module:
 			explode_interface_port(new_ast, intfmodule, intfname, modport);
diff --git a/frontends/ast/ast.h b/frontends/ast/ast.h
index 63104bca4..6e85dd40f 100644
--- a/frontends/ast/ast.h
+++ b/frontends/ast/ast.h
@@ -115,6 +115,7 @@ namespace AST
 		AST_LOGIC_OR,
 		AST_LOGIC_NOT,
 		AST_TERNARY,
+		AST_INSIDE,
 		AST_MEMRD,
 		AST_MEMWR,
 		AST_MEMINIT,
@@ -200,6 +201,8 @@ namespace AST
 		double realvalue;
 		// set for IDs typed to an enumeration, not used
 		bool is_enum;
+		// for AST_RANGES
+		bool is_packed;
 
 		// if this is a multirange memory then this vector contains offset and length of each dimension
 		std::vector<int> multirange_dimensions;
@@ -225,6 +228,8 @@ namespace AST
 		AstNode *clone() const;
 		void cloneInto(AstNode *other) const;
 		void delete_children();
+		AstNode* find_child(const std::string& name);
+		AstNode* find_child(AstNodeType type, const std::string& name);
 		~AstNode();
 
 		enum mem2reg_flags
@@ -280,6 +285,9 @@ namespace AST
 		bool is_recursive_function() const;
 		std::pair<AstNode*, AstNode*> get_tern_choice();
 
+		// Visit each descendant of this node and call the passed function on it
+		void visitEachDescendant(const std::function<void(AST::AstNode*)>& f);
+
 		// create a human-readable text representation of the AST (for debugging)
 		void dumpAst(FILE *f, std::string indent) const;
 		void dumpVlog(FILE *f, std::string indent) const;
@@ -304,6 +312,7 @@ namespace AST
 
 		// helper functions for creating AST nodes for constants
 		static AstNode *mkconst_int(uint32_t v, bool is_signed, int width = 32);
+		static AstNode *mkconst_real(double v);
 		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsized);
 		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed);
 		static AstNode *mkconst_str(const std::vector<RTLIL::State> &v);
@@ -376,7 +385,7 @@ namespace AST
 	void set_src_attr(RTLIL::AttrObject *obj, const AstNode *ast);
 
 	// struct helper exposed from simplify for genrtlil
-	AstNode *make_struct_member_range(AstNode *node, AstNode *member_node);
+	AstNode *make_struct_member_range(AstNode *node, AstNode *member_node, int move);
 }
 
 namespace AST_INTERNAL
diff --git a/frontends/ast/genrtlil.cc b/frontends/ast/genrtlil.cc
index c82664b98..096d5a889 100644
--- a/frontends/ast/genrtlil.cc
+++ b/frontends/ast/genrtlil.cc
@@ -878,7 +878,7 @@ void AstNode::detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *foun
 			if (children.size() > 1)
 				range = children[1];
 		} else if (id_ast->type == AST_STRUCT_ITEM) {
-			AstNode *tmp_range = make_struct_member_range(this, id_ast);
+			AstNode *tmp_range = make_struct_member_range(this, id_ast, 0);
 			this_width = tmp_range->range_left - tmp_range->range_right + 1;
 			delete tmp_range;
 		} else
diff --git a/frontends/ast/simplify.cc b/frontends/ast/simplify.cc
index f713cf8e1..78ec105ba 100644
--- a/frontends/ast/simplify.cc
+++ b/frontends/ast/simplify.cc
@@ -31,6 +31,7 @@
 #include "frontends/verilog/verilog_frontend.h"
 #include "ast.h"
 
+#include <algorithm>
 #include <sstream>
 #include <stdarg.h>
 #include <stdlib.h>
@@ -238,12 +239,17 @@ void AstNode::annotateTypedEnums(AstNode *template_node)
 	}
 }
 
-static bool name_has_dot(const std::string &name, std::string &struct_name)
+static bool name_has_dot(const std::string &name, std::string &struct_name, std::string &struct_field)
 {
 	// check if plausible struct member name \sss.mmm
-	std::string::size_type pos;
-	if (name.substr(0, 1) == "\\" && (pos = name.find('.', 0)) != std::string::npos) {
+	std::string::size_type start_pos = name.rfind(']');
+	if(start_pos == std::string::npos)
+		start_pos = 0;
+
+	std::string::size_type pos = name.find('.', start_pos);
+	if (name.substr(0, 1) == "\\" && (pos != std::string::npos)) {
 		struct_name = name.substr(0, pos);
+		struct_field = name.substr(pos); // return str with . at begining
 		return true;
 	}
 	return false;
@@ -307,9 +313,14 @@ static int size_packed_struct(AstNode *snode, int base_offset)
 		if (node->type == AST_STRUCT || node->type == AST_UNION) {
 			// embedded struct or union
 			width = size_packed_struct(node, base_offset + offset);
+			// set range of struct
+			node->range_right = base_offset + offset;
+			node->range_left = base_offset + offset + width - 1;
+			node->range_valid = true;
 		}
 		else {
 			log_assert(node->type == AST_STRUCT_ITEM);
+			while(node->simplify(false, false,false, 1, -1, false, false)) { }
 			if (node->children.size() > 0 && node->children[0]->type == AST_RANGE) {
 				// member width e.g. bit [7:0] a
 				width = range_width(node, node->children[0]);
@@ -351,6 +362,9 @@ static int size_packed_struct(AstNode *snode, int base_offset)
 					delete child;
 				node->children.clear();
 			}
+			else if (node->children.size() == 1 && node->children[0]->type == AST_ENUM) {
+				width = node->children[0]->children[0]->range_left - node->children[0]->children[0]->range_right + 1;
+			}
 			else if (node->range_left < 0) {
 				// 1 bit signal: bit, logic or reg
 				width = 1;
@@ -456,7 +470,7 @@ static AstNode *slice_range(AstNode *rnode, AstNode *snode)
 }
 
 
-AstNode *AST::make_struct_member_range(AstNode *node, AstNode *member_node)
+AstNode *AST::make_struct_member_range(AstNode *node, AstNode *member_node, int move)
 {
 	// Work out the range in the packed array that corresponds to a struct member
 	// taking into account any range operations applicable to the current node
@@ -465,18 +479,18 @@ AstNode *AST::make_struct_member_range(AstNode *node, AstNode *member_node)
 	int range_right = member_node->range_right;
 	if (node->children.empty()) {
 		// no range operations apply, return the whole width
-		return make_range(range_left, range_right);
+		return make_range(range_left + move, range_right + move);
 	}
 	int stride = get_struct_array_width(member_node);
 	if (node->children.size() == 1 && node->children[0]->type == AST_RANGE) {
 		// bit or array indexing e.g. s.a[2] or s.a[1:0]
-		return make_struct_index_range(node, node->children[0], stride, range_right);
+		return make_struct_index_range(node, node->children[0], stride, range_right + move);
 	}
 	else if (node->children.size() == 1 && node->children[0]->type == AST_MULTIRANGE) {
 		// multirange, i.e. bit slice after array index, e.g. s.a[i][p:q]
 		log_assert(stride > 1);
 		auto mrnode = node->children[0];
-		auto element_range = make_struct_index_range(node, mrnode->children[0], stride, range_right);
+		auto element_range = make_struct_index_range(node, mrnode->children[0], stride, range_right + move);
 		// then apply bit slice range
 		auto range = slice_range(element_range, mrnode->children[1]);
 		delete element_range;
@@ -497,10 +511,8 @@ static void add_members_to_scope(AstNode *snode, std::string name)
 			// embedded struct or union
 			add_members_to_scope(node, name + "." + node->str);
 		}
-		else {
-			auto member_name = name + "." + node->str;
-			current_scope[member_name] = node;
-		}
+		auto member_name = name + "." + node->str;
+		current_scope[member_name] = node;
 	}
 }
 
@@ -564,6 +576,85 @@ static std::string prefix_id(const std::string &prefix, const std::string &str)
 	return prefix + str;
 }
 
+static void flatten_ranges(AstNode *node)
+{
+	if ((node->children.size() <= 1)) {
+		return;
+	}
+
+	unsigned ranges = std::count_if(node->children.begin(),
+			node->children.end(),
+			[](AstNode *n){return n->type == AST_RANGE;});
+
+	if (ranges <= 1) {
+		return;
+	}
+
+	int size = 1;
+	// count size of vector (width)
+	for (const auto& itr : node->children) {
+		if (itr->type != AST_RANGE)
+			continue;
+
+		const int width = itr->range_left - itr->range_right + 1;
+		size *= width;
+	}
+
+	// remove ranges
+	size_t i = 0;
+	while(i < node->children.size())
+	{
+		if (node->children[i]->type != AST_RANGE){
+			i++;
+			continue;
+		}
+		delete *(node->children.begin() + i);
+		node->children.erase(node->children.begin() + i);
+	}
+
+	// Place new one-dimensional range (packed vector)
+	AstNode* simple_range = new AstNode(AST_RANGE);
+	simple_range->integer = size;
+	simple_range->children.push_back(node->mkconst_int(size - 1, false, 32));
+	simple_range->children.push_back(node->mkconst_int(0, false, 32));
+	node->children.push_back(simple_range);
+}
+
+static bool make_mutliranges(AstNode *node, bool packed = false)
+{
+	if ((node->children.size() <= 1)) {
+		return false;
+	}
+
+	unsigned ranges = std::count_if(node->children.begin(),
+			node->children.end(),
+			[](AstNode *n){return n->type == AST_RANGE;});
+
+	if (ranges <= 1) {
+		return false;
+	}
+
+	AstNode* simple_multirange = new AstNode(AST_MULTIRANGE);
+	// remove ranges
+	size_t i = 0;
+	while(i < node->children.size())
+	{
+		if (node->children[i]->type != AST_RANGE){
+			i++;
+			continue;
+		}
+		simple_multirange->children.push_back(node->children[i]->clone());
+		delete *(node->children.begin() + i);
+		node->children.erase(node->children.begin() + i);
+	}
+
+	// Place new one-dimensional range (packed vector)
+	simple_multirange->integer = ranges;
+	simple_multirange->is_packed = packed;
+	node->children.push_back(simple_multirange);
+	return true;
+}
+
 // convert the AST into a simpler AST that has all parameters substituted by their
 // values, unrolled for-loops, expanded generate blocks, etc. when this function
 // is done with an AST it can be converted into RTLIL using genRTLIL().
@@ -946,6 +1037,32 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 	bool children_are_self_determined = false;
 	bool reset_width_after_children = false;
 
+	if ((type == AST_GENFOR || type == AST_FOR) && children.size() != 0)
+	{
+		AstNode *scope_node = current_ast_mod;
+		AstNode *init_ast = children[0];
+		if (init_ast->type == AST_ASSIGN_EQ && init_ast->children[0]->type != AST_IDENTIFIER) {
+			if (type == AST_GENFOR) {
+				std::string scope_str = "$loopvar$" + std::to_string(autoidx++);
+				std::string old_name = init_ast->children[0]->str;
+				this->visitEachDescendant([&](AST::AstNode* node) {
+						if (node->str == old_name && node->type == AST_IDENTIFIER) {
+							node->str = scope_str + "$" + old_name.substr(1);
+						}
+						});
+				init_ast->children[0]->str = scope_str + "$" + old_name.substr(1);
+			}
+			scope_node->children.insert(scope_node->children.begin(), init_ast->children[0]);
+			init_ast->children[0]->simplify(false, false, true, stage, -1, false, in_param);
+			auto *clone = init_ast->children[0]->clone();
+			clone->type = AST_IDENTIFIER;
+			clone->id2ast = init_ast->children[0];
+			clone->children.clear();
+
+			init_ast->children[0] = clone;
+		}
+	}
+
 	switch (type)
 	{
 	case AST_ASSIGN_EQ:
@@ -981,6 +1098,65 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 					log_warning("reg '%s' is assigned in a continuous assignment at %s.\n", children[0]->str.c_str(), loc_string().c_str());
 			}
 			children[0]->was_checked = true;
+
+			// assigning multirange arrays?
+			if (children.size() >= 2 && current_scope.count(children[0]->str) > 0 && current_scope.count(children[1]->str) > 0) {
+				const auto* lhs = current_scope.at(children[0]->str);
+				const auto* rhs = current_scope.at(children[1]->str);
+
+				const auto lhs_range = lhs->range_left - lhs->range_right + 1;
+
+				// Apply workaround only for port wire
+				if ((lhs && (lhs->port_id > 0)) || (rhs && (rhs->port_id > 0))) {
+					int ranges[2] = {0};
+
+					if (lhs) {
+						for (const auto* node : lhs->children) {
+							if (node->type == AST_RANGE)
+								ranges[0] += 1;
+						}
+					}
+
+					if (rhs) {
+						for (const auto* node : rhs->children) {
+							if (node->type == AST_RANGE)
+								ranges[1] += 1;
+						}
+					}
+
+					if ((ranges[0] == 1) && (ranges[1] == 2)) {
+						// assign a = b;
+						if ((children[0]->children.size() == 0) && (children[1]->children.size() == 0)) {
+
+							AstNode* rhs = new AstNode;
+							rhs->type = AST_CONCAT;
+							int number_of_nodes = lhs_range / lhs->children[0]->integer; //TODO: is this good way to store size of array?
+							for (int i = 0 ; i < number_of_nodes ; ++i) {
+								AstNode* temp = new AstNode;
+								temp->type = AST_IDENTIFIER;
+								temp->str = children[1]->str;
+
+								temp->children.push_back(new AstNode);
+								temp->children[0]->type = AST_RANGE;
+								temp->children[0]->integer = i;
+								temp->children[0]->children.push_back(new AstNode);
+								temp->children[0]->children[0]->type = AST_CONSTANT;
+								temp->children[0]->children[0]->integer = i;
+
+								//while (temp->simplify(const_fold, at_zero, in_lvalue, stage, width_hint, sign_hint, in_param)) {};
+
+								rhs->children.push_back(temp);
+							}
+
+							children[1] = rhs; // memory leak
+							//while (rhs->simplify(const_fold, at_zero, in_lvalue, stage, width_hint, sign_hint, in_param)) {};
+							did_something = true;
+							//return true;
+						} // else (unsupported assignment)
+					}
+				}
+				// TODO: Other way around, e.g. multi <= single (needed e.g. in upper-hier. level module)
+			}
 		}
 		break;
 
@@ -1083,6 +1259,10 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 	case AST_SHIFT_RIGHT:
 	case AST_SHIFT_SLEFT:
 	case AST_SHIFT_SRIGHT:
+		log_assert(children.size() > 1);
+		// 11.4.10 Shift operators
+		// The right operand is always treated as an unsigned number
+		children[1]->is_signed = false;
 	case AST_POW:
 		detect_width_simple = true;
 		child_1_is_self_determined = true;
@@ -1189,6 +1369,7 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 
 	if (const_fold && type == AST_CASE)
 	{
+		while (children[0]->simplify(const_fold, at_zero, in_lvalue, stage, width_hint, sign_hint, in_param)) { }
 		int width_hint;
 		bool sign_hint;
 		detectSignWidth(width_hint, sign_hint);
@@ -1413,10 +1594,31 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 			if (template_node->type == AST_STRUCT || template_node->type == AST_UNION) {
 				// replace with wire representing the packed structure
 				newNode = make_packed_struct(template_node, str);
-				// add original input/output attribute to resolved wire
+				if (children.size() == 2 && children[1]->type == AST_RANGE && port_id == 0 && type == AST_WIRE) {
+					if(!make_mutliranges(this, true)){
+						constexpr int has_unpacked_range = 1;
+						newNode->attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
+						newNode->attributes[ID::wiretype]->children.push_back(children[1]->clone()); // save unpacked size
+						newNode->attributes[ID::wiretype]->is_packed= has_unpacked_range;
+					}
+ 					int s = std::abs(int(children[1]->children[0]->integer - children[1]->children[1]->integer)) + 1;
+ 					newNode->children[0]->range_left = (newNode->children[0]->range_left + 1) * s;
+ 					newNode->children[0]->children[0]->integer = (newNode->children[0]->children[0]->integer + 1) * s;
+ 					newNode->children[0]->range_left -= 1;
+ 					newNode->children[0]->children[0]->integer -= 1;
+
+				} else if(children.size() == 2 && children[1]->type == AST_RANGE) {
+					constexpr int has_unpacked_range = 1;
+					newNode->attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
+					newNode->attributes[ID::wiretype]->children.push_back(children[1]->clone()); // save unpacked size
+					newNode->attributes[ID::wiretype]->is_packed = has_unpacked_range;
+					newNode->children.push_back(children[1]->clone());
+				}
 				newNode->is_input = this->is_input;
 				newNode->is_output = this->is_output;
 				current_scope[str] = this;
+				newNode->port_id = this->port_id;
+				newNode->type = this->type;
 				goto apply_newNode;
 			}
 
@@ -1437,14 +1639,38 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 			range_left = template_node->range_left;
 			range_right = template_node->range_right;
 
-			attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
 
 			// if an enum then add attributes to support simulator tracing
 			annotateTypedEnums(template_node);
 
+			const bool wire_has_range = children.size() == 1 && children[0]->type == AST_RANGE && this->type != AST_MEMORY;
+			const int range_span = wire_has_range ? children[0]->children[1]->integer + 1 : 1;
+			if(range_span > 1)
+			{
+				delete children[0];
+				children.pop_back();
+			}
+
 			// Insert clones children from template at beginning
-			for (int i  = 0; i < GetSize(template_node->children); i++)
-				children.insert(children.begin() + i, template_node->children[i]->clone());
+			for (int i  = 0; i < GetSize(template_node->children); i++) {
+				if (template_node->children[i]->type == AST_RANGE && range_span > 1) {
+					auto *clone = template_node->children[i]->clone();
+					int size = clone->range_left - clone->range_right + 1;
+					clone->range_left = size * range_span - 1;
+					clone->children[0]->integer = clone->range_left;
+					range_left = clone->range_left;
+					children.insert(children.begin() + i, clone);
+				} else {
+					children.insert(children.begin() + i, template_node->children[i]->clone());
+				}
+			}
+			if(type != AST_MEMORY){
+				if(!make_mutliranges(this, true))
+				{
+					attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
+					attributes[ID::wiretype]->is_packed= wire_has_range;
+				}
+			}
 
 			if (type == AST_MEMORY && GetSize(children) == 1) {
 				// Single-bit memories must have [0:0] range
@@ -1453,6 +1679,51 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 			}
 			did_something = true;
 		}
+
+		// Convert only port wires
+		if ((port_id > 0)) {
+			flatten_ranges(this);
+		}
+
+		// FIXME: Basically same thing as above, should be merged
+		if (children.size() == 1 && children[0]->type == AST_MULTIRANGE && children[0]->is_packed) {
+			const auto* multirange = children[0];
+			const size_t ranges = std::count_if(
+				multirange->children.begin(), multirange->children.end(),
+				[](const AstNode* node) {
+					return node->type == AST_RANGE;
+				});
+			// More than two dimensions should be supported, but tested only 2.
+			if ((ranges == multirange->children.size())) {
+				size_t size = 1;
+
+				auto* attr_ranges = new AstNode;
+				attr_ranges->type = AST_CONSTANT;
+
+				for (const auto& itr : multirange->children) {
+					log_assert(itr->type == AST_RANGE);
+					const auto width = itr->range_left - itr->range_right + 1;
+					size *= width;
+					attr_ranges->children.push_back(itr->clone());
+				}
+				attr_ranges->range_left  = size - 1;
+				attr_ranges->range_right = 0;
+				attributes[ID::multirange] = attr_ranges;
+
+				// Replace with one-dimensional range (packed vector)
+				AstNode* simple_range = new AstNode(AST_RANGE);
+				simple_range->integer = size;
+				simple_range->children.push_back(mkconst_int(size - 1, false, 32));
+				simple_range->children.push_back(mkconst_int(0, false, 32));
+				delete children[0];
+				children.clear();
+				children.push_back(simple_range);
+
+				is_packed = true;
+				did_something = true;
+			}
+		}
+
 		log_assert(!is_custom_type);
 	}
 
@@ -1489,6 +1760,59 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 				children.push_back(template_child->clone());
 			did_something = true;
 		}
+
+		// FIXME: move to separate function
+		for (size_t i = 0 ; i < children.size() ; ++i) {
+			if (children[i]->type == AST_MULTIRANGE) {// && children[i]->is_packed) {
+			//if (children[i]->type == AST_MULTIRANGE && attributes.count(ID::multirange) == 0) {// && children[i]->is_packed) {
+				const auto* multirange = children[i];
+				const size_t ranges = std::count_if(
+					multirange->children.begin(), multirange->children.end(),
+					[](const AstNode* node) {
+						return node->type == AST_RANGE;
+					});
+
+				// More than two dimensions should be supported, but tested only 2.
+				if ((ranges == 2) && (ranges == multirange->children.size())) {
+					size_t size = 1;
+
+					auto* attr_ranges = new AstNode;
+					attr_ranges->type = AST_CONSTANT;
+
+					for (const auto& itr : multirange->children) {
+						log_assert(itr->type == AST_RANGE);
+						if (itr->children.size() == 2) {
+							const auto width = itr->range_left - itr->range_right + 1;
+							size *= width;
+						} else {
+							const auto width = itr->range_left;
+							size *= width;
+						}
+						attr_ranges->children.push_back(itr->clone());
+					}
+					attr_ranges->range_left  = size - 1;
+					attr_ranges->range_right = 0;
+					attributes[ID::multirange] = attr_ranges;
+
+					// Replace with one-dimensional range (packed vector)
+					AstNode* simple_range = new AstNode(AST_RANGE);
+					simple_range->integer = size;
+					simple_range->children.push_back(mkconst_int(size - 1, false, 32));
+					simple_range->children.push_back(mkconst_int(0, false, 32));
+					simple_range->range_left = size - 1;
+					simple_range->range_right = 0;
+					simple_range->range_valid = true;
+
+					delete children[i];
+					children.erase(children.begin() + i);
+					children.push_back(simple_range);
+
+					is_packed = true;
+					did_something = true;
+				}
+				break;
+			}
+		}
 		log_assert(!is_custom_type);
 	}
 
@@ -1553,6 +1877,9 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 	// annotate wires with their ranges
 	if (type == AST_WIRE) {
 		if (children.size() > 0) {
+			if (!children[0]->range_valid) { // if range is not valid, make sure children is simplify
+				while(children[0]->simplify(true, false, false, stage, -1, -1, false)) {}
+			}
 			if (children[0]->range_valid) {
 				if (!range_valid)
 					did_something = true;
@@ -1609,6 +1936,222 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 		did_something = true;
 	}
 
+	// Access multirange array replaced by registers?
+	if (type == AST_ARGUMENT) {
+		if (children.size() == 1 && children[0]->type == AST_IDENTIFIER) {
+			auto* identifier = children[0];
+			if(identifier->type == AST_IDENTIFIER) {
+				if (identifier->children.size() == 0 && current_scope.count(identifier->str) > 0 && current_scope[identifier->str]->type == AST_MEMORY && current_scope[identifier->str]->children.size() == 2) {
+					identifier->children.push_back(current_scope[identifier->str]->children[1]->clone());
+
+					AstNode *mem = current_scope[identifier->str]; // force mem to be replaced by list of registers, as code below, assumes this
+					AstNode *force_reg = new AstNode(AST_CONSTANT);
+					force_reg->integer = 1;
+					mem->attributes[ID::mem2reg] = force_reg;
+				}
+			}
+			if (identifier->children.size() == 1 && identifier->children[0]->type == AST_RANGE) {
+				auto* range = identifier->children[0];
+				if (range->children.size() == 2 &&
+						range->children[0]->type == AST_CONSTANT &&
+						range->children[1]->type == AST_CONSTANT) {
+					int left = range->children[0]->integer;
+					int right = range->children[1]->integer;
+					if (left > right) {
+						int tmp = left;
+						left = right;
+						right = tmp;
+					}
+
+					if (current_scope.count(identifier->str)) {
+						const auto* reg_node = current_scope.at(identifier->str);
+						const auto ranges = std::count_if(
+							reg_node->children.begin(), reg_node->children.end(),
+							[](const AstNode* node) {
+								return node->type == AST_RANGE;
+							});
+
+						if (ranges == 2) {
+							// FIXME: this assumes that identifier would be replaced by list of registers
+							AstNode* concat = new AstNode;
+							concat->type = AST_CONCAT;
+
+							for (int i = left ; i <= right ; ++i) {
+								AstNode* temp = new AstNode;
+								temp->type = AST_IDENTIFIER;
+								temp->str = identifier->str;
+								temp->children.push_back(new AstNode);
+								temp->children[0]->type = AST_RANGE;
+								temp->children[0]->children.push_back(new AstNode);
+								temp->children[0]->children[0]->type = AST_CONSTANT;
+								temp->children[0]->children[0]->integer = i;
+								concat->children.push_back(temp);
+							}
+
+							// Delete multirange
+							delete children[0];
+							children.clear();
+							// And replace with CONCAT
+							children.push_back(concat);
+
+							did_something = true;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	// Replace multirange acces with vector and range access
+	if (type == AST_IDENTIFIER) {
+		if (current_scope.count(str)) {
+			const auto* temp = current_scope.at(str);
+			log_assert(temp);
+
+			// is this multidimensional array?
+			if (temp->is_packed && temp->attributes.count(ID::multirange)) {
+				const auto* ranges = temp->attributes.at(ID::multirange);
+				log_assert(ranges);
+				log_assert(ranges->type == AST_CONSTANT);
+
+				if (attributes.count(ID::multirange) == 0) {
+					attributes[ID::multirange] = ranges->clone();
+
+					// FIXME: messy, clean this up
+					size_t _offset = 0;
+					size_t _range_left  = ranges->range_left;
+					size_t _range_right = ranges->range_right;
+					size_t _width = _range_left - _range_right + 1;
+
+					const AstNode* multi = nullptr;
+
+					// FIXME: more configurations
+					if (children.size() == 1 && children[0]->type == AST_RANGE) {
+
+						if (children[0]->children[0]->type == AST_IDENTIFIER) {
+							// FIXME: should be merged with below code
+							const auto* id = children[0]->children[0];
+							const auto* r = ranges->children[0]; // r as (orig) Range
+							const size_t r_width = r->range_left - r->range_right + 1;
+							_width /= r_width;
+
+							// for logic [a:b][c] arr;
+							// and arr[d]
+							// generates arr[ ((d*c) + d - 1 : (d*c) ];
+
+							// d * c
+							auto* x2 = new AstNode;
+							x2->type = AST_MUL;
+							x2->children.push_back(id->clone());
+							x2->children.push_back(mkconst_int(_width, false, 32));
+
+							auto *x2_self = new AstNode(AST_SELFSZ, x2);
+
+							auto* x3_add = new AstNode;
+							x3_add->type = AST_ADD;
+							x3_add->children.push_back(x2_self);
+							x3_add->children.push_back(mkconst_int(_width, false, 32));
+
+							// x3 - 1
+							auto* x3 = new AstNode;
+							x3->type = AST_SUB;
+							x3->children.push_back(x3_add);
+							x3->children.push_back(mkconst_int(1, false, 32));
+
+							// d * c
+							auto* x4 = new AstNode;
+							x4->type = AST_MUL;
+							x4->children.push_back(id->clone());
+							x4->children.push_back(mkconst_int(_width, false, 32));
+
+							auto* x4_self = new AstNode(AST_SELFSZ, x4);
+
+							auto *x4_add = new AstNode(AST_ADD, x4_self, mkconst_int(0, false, 32));
+
+							// x3:x4
+							AstNode* simple_range = new AstNode(AST_RANGE);
+							simple_range->children.push_back(x3);
+							simple_range->children.push_back(x4_add);
+							delete children[0];
+							children.erase(children.begin());
+							children.insert(children.begin(), simple_range);
+						} else {
+							// replace with multirange
+							AstNode* temp = new AstNode(AST_MULTIRANGE);
+							temp->children.push_back(children[0]);
+							children[0] = temp;
+
+							multi = children[0];
+							log_assert(multi->children.size() == 1);
+						}
+					} else if (children.size() == 1 && children[0]->type == AST_MULTIRANGE) {
+						multi = children[0];
+					}
+
+					if (multi) {
+						if(multi->children.size() > ranges->children.size())
+						{
+							log_error("Access to not existing element\n");
+						}
+
+						AstNode* simple_range = new AstNode(AST_RANGE);
+						for (size_t idx = 0 ; idx < multi->children.size() ; ++idx) {
+							if (multi->children[0]->children[0]->type != AST_CONSTANT) {
+								AstNode *mul = new AstNode(AST_MUL);
+								mul->children.push_back(multi->children[idx]->children[0]->clone());
+								const auto* r = ranges->children[1]; // r as (orig) Range
+								const size_t r_width = r->range_left - r->range_right + 1;
+								AstNode *width = new AstNode(AST_CONSTANT);
+								width->integer = r_width;
+								mul->children.push_back(width);
+								simple_range->children.push_back(mul);
+							} else {
+								const size_t r_idx = idx;
+
+								const auto* s = multi->children[idx]; // s as Selected range
+
+								const auto* r = ranges->children[r_idx]; // r as (orig) Range
+								const size_t r_width = r->range_left - r->range_right + 1;
+
+								_width /= r_width;
+ 								int start_idx = 0;
+								if (ranges->children[1]->range_swapped) {
+									if (idx == 0) {
+										start_idx = ranges->children[1]->children[1]->integer;
+										_width = r_width;
+										_range_left  = (start_idx - (s->range_left))  * _width + (_width - 1) + _offset;
+										_range_right = (start_idx - (s->range_right)) * _width                + _offset;
+									} else {
+										_range_left  += (s->range_left - ranges->children[0]->range_left);
+										_range_right += (s->range_right - ranges->children[0]->range_right);
+									}
+								} else {
+									_range_left  = ((s->range_left))  * _width + (_width - 1) + _offset;
+									_range_right = ((s->range_right)) * _width                + _offset;
+ 								}
+								_offset = _range_right;
+							}
+						}
+
+						// remove multirange
+						children.erase(children.begin());
+						delete multi;
+
+						// replace with simple (one-dimension) range (packed vector)
+						//log("replaced_range: [%ld:%ld]\n", _range_left, _range_right);
+						//if (_range_left < 0)  _range_left = 0;
+						//if (_range_right < 0) _range_right = 0;
+						if (simple_range->children.size() == 0) {
+							simple_range->children.push_back(mkconst_int(_range_left,  false, 32));
+							simple_range->children.push_back(mkconst_int(_range_right, false, 32));
+						}
+						children.insert(children.begin(), simple_range);
+					}
+				}
+			}
+		}
+	}
+
 	// resolve multiranges on memory access
 	if (type == AST_IDENTIFIER && id2ast && id2ast->type == AST_MEMORY && children.size() > 0 && children[0]->type == AST_MULTIRANGE)
 	{
@@ -1683,13 +2226,61 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 
 	if (type == AST_IDENTIFIER && !basic_prep) {
 		// check if a plausible struct member sss.mmmm
-		std::string sname;
-		if (name_has_dot(str, sname)) {
-			if (current_scope.count(str) > 0) {
-				auto item_node = current_scope[str];
-				if (item_node->type == AST_STRUCT_ITEM) {
+		// check if a plausible struct member sss[srange]
+		// check if a plausible struct member sss[srange].mmmm
+		std::string sname, sfield, srange;
+		if (name_has_dot(str, sname, sfield)) {
+			std::string::size_type pos_start = sname.find("[", 0);
+			std::string::size_type pos_end = sname.rfind("]");
+			std::string look_str = str;
+			int struct_size = 0;
+			int struct_mult = 0;
+			if (pos_start != std::string::npos && pos_end != std::string::npos) {
+				srange = sname.substr(pos_start + 1, pos_end - pos_start - 1);
+				sname = sname.substr(0, pos_start);
+				if (!srange.empty() && std::find_if(srange.begin(), srange.end(), [](unsigned char c) { return !std::isdigit(c); }) == srange.end()) {
+					struct_mult = stoi(srange);
+				} else {
+					for(auto it = current_scope.rbegin(); it != current_scope.rend(); it++) {
+						auto s = *it;
+						// append '\' to srange to make sure we find correct wire
+						if (s.first == "\\" + srange && s.second->children.size() > 0 && s.second->children[0]->integer > 0) {
+							struct_mult = s.second->children[0]->integer;
+							break;
+						}
+					}
+				}
+				look_str = sname + sfield;
+				if (current_scope.count(sname) > 0 && current_scope.count(str) == 0) {
+					auto wire = current_scope[sname];
+					if (wire->attributes.count(ID::wiretype) && current_scope.count(wire->attributes[ID::wiretype]->str)) {
+						const auto *attributes = wire->attributes[ID::wiretype];
+						const auto *wiretype = current_scope[attributes->str];
+						const auto *wiretype_range = wiretype->children[0]->children[0];
+
+						if (attributes->children.size() > 0) {
+							struct_size = wiretype_range->range_left + 1;
+							if(attributes->children[0]->range_swapped) {
+								struct_mult = attributes->children[0]->range_left - struct_mult;
+							}
+						} else {
+							struct_size = wiretype->integer;
+						}
+					}
+				}
+			}
+			if (current_scope.count(look_str) < 1) {
+				look_str = str;
+				sname = str.substr(0, str.rfind("."));
+			}
+			if ((current_scope.count(sname) > 0) && (current_scope[sname]->type == AST_STRUCT_ITEM || current_scope[sname]->type == AST_STRUCT)) {
+				while(current_scope[sname]->simplify(true, false, false, 1, -1, false, false)) { }
+			}
+			if (current_scope.count(look_str) > 0) {
+				auto item_node = current_scope[look_str];
+				if (item_node->type == AST_STRUCT_ITEM || item_node->type == AST_STRUCT) {
 					// structure member, rewrite this node to reference the packed struct wire
-					auto range = make_struct_member_range(this, item_node);
+					auto range = make_struct_member_range(this, item_node, struct_size * struct_mult);
 					newNode = new AstNode(AST_IDENTIFIER, range);
 					newNode->str = sname;
 					newNode->basic_prep = true;
@@ -1698,7 +2289,60 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 					goto apply_newNode;
 				}
 			}
+		} else if (children.size() == 1 && children[0]->type == AST_RANGE) {
+			if (current_scope.count(str) > 0) {
+				while(current_scope[str]->simplify(true, false, false, 1, -1, false, false)) { }
+				if(current_scope[str]->attributes.count(ID::wiretype) && current_scope[str]->type != AST_MEMORY
+						&& current_scope.count(current_scope[str]->attributes[ID::wiretype]->str)
+						&& current_scope[str]->attributes[ID::wiretype]->is_packed)
+				{
+					const auto *attributes = current_scope[str]->attributes[ID::wiretype];
+
+					const auto *wiretype = current_scope[attributes->str];
+					const auto *wiretype_range = wiretype->children[0]->children[0];
+					const auto *current_range = children[0]->children[0];
+					int  element_idx = current_range->integer;
+					const int  size = wiretype_range->range_left + 1;
+
+					if(attributes->children.size() == 1)
+					{
+						const bool range_inversed = attributes->children[0]->range_swapped;
+						if(range_inversed)
+						{
+							element_idx = attributes->children[0]->range_left - element_idx;
+						}
+					}
+					const int upper_bound = size*(element_idx+1)-1;
+					const int lower_bound = size*element_idx;
+
+					auto *range = make_range(upper_bound, lower_bound);
+					delete children[0];
+					children[0] = range;
+					basic_prep = true;
+				}
+			}
+		}
+	}
+	if (type == AST_INSIDE) {
+		AstNode *inside_node = this->children.back()->clone();
+		inside_node->children.clear();
+		newNode = new AstNode(AST_BIT_OR);
+		newNode->str = inside_node->str;
+		auto *child_add = &newNode->children;
+		int number_of_ors = this->children.back()->children.size() - 2;
+		for (int i = 0; i < number_of_ors; i++) {
+			AstNode *or_node = new AstNode(AST_BIT_OR);
+			or_node->str = inside_node->str;
+			child_add->push_back(or_node);
+			child_add = &child_add->back()->children;
 		}
+		child_add = &newNode->children;
+		for(const auto &child : this->children.back()->children) {
+			if(child_add->size() == 2)
+				child_add = &(child_add->front()->children);
+			child_add->push_back(new AstNode(AST_EQ, inside_node->clone(), child->clone())); // TODO: For integral expressions, wildcard equality (==?) should be used
+		}
+		goto apply_newNode;
 	}
 	// annotate identifiers using scope resolution and create auto-wires as needed
 	if (type == AST_IDENTIFIER) {
@@ -2032,6 +2676,14 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 		}
 
 		for (size_t i = 0; i < children.size(); i++) {
+			if (children[i]->type == AST_WIRE || children[i]->type == AST_MEMORY || children[i]->type == AST_PARAMETER || children[i]->type == AST_LOCALPARAM || children[i]->type == AST_TYPEDEF || children[i]->type == AST_ENUM) {
+				current_scope[children[i]->str] = children[i];
+				for(auto *c : children[i]->children) {
+					if (c->type == AST_ENUM_ITEM) {
+						current_scope[c->str] = c;
+					}
+				}
+			}
 			children[i]->simplify(const_fold, false, false, stage, -1, false, false);
 			current_ast_mod->children.push_back(children[i]);
 		}
@@ -2568,6 +3220,67 @@ skip_dynamic_range_lvalue_expansion:;
 		}
 	}
 
+	if(children.size() > 0) {
+		for (auto *c : children) {
+			if (c->type == AST_ASSIGN_EQ || c->type == AST_ASSIGN_LE || c->type == AST_ASSIGN) {
+				const auto *lhs = c->children[0];
+				if(lhs->type == AST_IDENTIFIER && lhs->id2ast && lhs->id2ast->type == AST_MEMORY && lhs->children.size() == 0 && lhs->id2ast->children.size() == 2) {
+					AstNode *mem = lhs->id2ast;
+					AstNode *force_reg = new AstNode(AST_CONSTANT);
+					force_reg->integer = 1;
+					mem->attributes[ID::mem2reg] = force_reg; //force mem to be changed to registers
+
+					for (auto *cc : c->children) { //only for a = b
+						if (cc->type == AST_IDENTIFIER) {
+							auto *identifier = cc;
+							AstNode *rangenode = new AstNode(AST_RANGE);
+							AstNode *id = new AstNode(AST_CONSTANT);
+							id->integer = 0;
+							rangenode->children.push_back(id);
+							rangenode->range_left = 0;
+							rangenode->range_right = 0;
+							identifier->children.push_back(rangenode);
+						}
+					}
+					const auto *range = mem->children[1];
+					AstNode *clone = c->clone();
+					auto pos = std::find(children.begin(), children.end(), c); // find position of current node
+					log_assert(pos != children.end());
+					int left = range->range_left;
+					int right = range->range_right;
+					if (left > right) {
+						int tmp = left;
+						left = right;
+						right = tmp;
+					}
+					for (int i = left; i <= right ; ++i) {
+						AstNode *cl;
+						if (i == left)
+							cl = c;
+						else
+							cl = clone->clone();
+						cl->children[0]->children[0]->range_left = i;
+						cl->children[0]->children[0]->range_right = i;
+						cl->children[0]->children[0]->children[0]->integer = i;
+						cl->children[0]->children[0]->range_valid = true;
+						if(cl->children[1]->type == AST_IDENTIFIER) {
+							cl->children[1]->children[0]->range_left = i;
+							cl->children[1]->children[0]->range_right = i;
+							cl->children[1]->children[0]->children[0]->integer = i;
+							cl->children[1]->children[0]->range_valid = true;
+						}
+						else if (cl->children[1]->type == AST_CONCAT) {
+							cl->children[1] = cl->children[1]->children[i];
+						}
+						if (i != left)
+							children.insert(pos, cl);
+					}
+					did_something = true;
+				}
+			}
+		}
+
+	}
 	// assignment with memory in left-hand side expression -> replace with memory write port
 	if (stage > 1 && (type == AST_ASSIGN_EQ || type == AST_ASSIGN_LE) && children[0]->type == AST_IDENTIFIER &&
 			children[0]->id2ast && children[0]->id2ast->type == AST_MEMORY && children[0]->id2ast->children.size() >= 2 &&
@@ -3628,6 +4341,14 @@ replace_fcall_later:;
 							tmp_range_left = (param_width + 2*param_offset) - children[0]->range_right - 1;
 							tmp_range_right = (param_width + 2*param_offset) - children[0]->range_left - 1;
 						}
+
+						if (current_scope[str]->children.size() == 2 && current_scope[str]->children[1]->type == AST_MULTIRANGE && current_scope[str]->children[1]->children[0]->type == AST_RANGE) {
+							AstNode *range = current_scope[str]->children[1]->children[0];
+							int range_access = range->range_left;
+							tmp_range_right *= range_access;
+							tmp_range_left = (tmp_range_left + 1) * range_access;
+
+						}
 						for (int i = tmp_range_right; i <= tmp_range_left; i++) {
 							int index = i - param_offset;
 							if (0 <= index && index < param_width)
@@ -4336,7 +5057,6 @@ bool AstNode::mem2reg_check(pool<AstNode*> &mem2reg_set)
 {
 	if (type != AST_IDENTIFIER || !id2ast || !mem2reg_set.count(id2ast))
 		return false;
-
 	if (children.empty() || children[0]->type != AST_RANGE || GetSize(children[0]->children) != 1)
 		log_file_error(filename, location.first_line, "Invalid array access.\n");
 
diff --git a/frontends/verilog/Makefile.inc b/frontends/verilog/Makefile.inc
index 2c923f0b7..cf9b9531e 100644
--- a/frontends/verilog/Makefile.inc
+++ b/frontends/verilog/Makefile.inc
@@ -6,7 +6,7 @@ GENFILES += frontends/verilog/verilog_lexer.cc
 
 frontends/verilog/verilog_parser.tab.cc: frontends/verilog/verilog_parser.y
 	$(Q) mkdir -p $(dir $@)
-	$(P) $(BISON) -Wall -Werror -o $@ -d -r all -b frontends/verilog/verilog_parser $<
+	$(P) $(BISON) -o $@ -d -r all -b frontends/verilog/verilog_parser $<
 
 frontends/verilog/verilog_parser.tab.hh: frontends/verilog/verilog_parser.tab.cc
 
diff --git a/frontends/verilog/verilog_lexer.l b/frontends/verilog/verilog_lexer.l
index 0306f5494..ce6142cce 100644
--- a/frontends/verilog/verilog_lexer.l
+++ b/frontends/verilog/verilog_lexer.l
@@ -236,6 +236,7 @@ static bool isUserType(std::string &s)
 "unique"       { SV_KEYWORD(TOK_UNIQUE); }
 "unique0"      { SV_KEYWORD(TOK_UNIQUE0); }
 "priority"     { SV_KEYWORD(TOK_PRIORITY); }
+"inside"       { SV_KEYWORD(TOK_INSIDE); }
 
 "always_comb"  { SV_KEYWORD(TOK_ALWAYS_COMB); }
 "always_ff"    { SV_KEYWORD(TOK_ALWAYS_FF); }
diff --git a/frontends/verilog/verilog_parser.y b/frontends/verilog/verilog_parser.y
index b0c16c0f4..47988644d 100644
--- a/frontends/verilog/verilog_parser.y
+++ b/frontends/verilog/verilog_parser.y
@@ -305,7 +305,7 @@ static void checkLabelsMatch(const char *element, const std::string *before, con
 %token TOK_RAND TOK_CONST TOK_CHECKER TOK_ENDCHECKER TOK_EVENTUALLY
 %token TOK_INCREMENT TOK_DECREMENT TOK_UNIQUE TOK_UNIQUE0 TOK_PRIORITY
 %token TOK_STRUCT TOK_PACKED TOK_UNSIGNED TOK_INT TOK_BYTE TOK_SHORTINT TOK_LONGINT TOK_UNION
-%token TOK_BIT_OR_ASSIGN TOK_BIT_AND_ASSIGN TOK_BIT_XOR_ASSIGN TOK_ADD_ASSIGN
+%token TOK_BIT_OR_ASSIGN TOK_BIT_AND_ASSIGN TOK_BIT_XOR_ASSIGN TOK_ADD_ASSIGN TOK_INSIDE
 %token TOK_SUB_ASSIGN TOK_DIV_ASSIGN TOK_MOD_ASSIGN TOK_MUL_ASSIGN
 %token TOK_SHL_ASSIGN TOK_SHR_ASSIGN TOK_SSHL_ASSIGN TOK_SSHR_ASSIGN
 %token TOK_BIND
@@ -574,7 +574,8 @@ module_arg:
 		ast_stack.back()->children.push_back(astbuf2);
 		delete astbuf1; // really only needed if multiple instances of same type.
 	} module_arg_opt_assignment |
-	attr wire_type range TOK_ID {
+//	attr wire_type range TOK_ID { // use multirange_dimensions or sth...
+	attr wire_type range TOK_ID range {
 		AstNode *node = $2;
 		node->str = *$4;
 		SET_AST_NODE_LOC(node, @4, @4);
@@ -582,6 +583,16 @@ module_arg:
 		AstNode *range = checkRange(node, $3);
 		if (range != NULL)
 			node->children.push_back(range);
+		if ($5 != NULL) {
+			// we should really re-use code from wire_name
+			auto *rangeNode = $5;
+			if (rangeNode->type == AST_RANGE && rangeNode->children.size() == 1) {
+				// SV array size [n], rewrite as [n-1:0]
+				rangeNode->children[0] = new AstNode(AST_SUB, rangeNode->children[0], AstNode::mkconst_int(1, true));
+				rangeNode->children.push_back(AstNode::mkconst_int(0, false));
+			}
+			node->children.push_back(rangeNode);
+		}
 		if (!node->is_input && !node->is_output)
 			frontend_verilog_yyerror("Module port `%s' is neither input nor output.", $4->c_str());
 		if (node->is_reg && node->is_input && !node->is_output && !sv_mode)
@@ -1819,10 +1830,14 @@ struct_var: TOK_ID	{	auto *var_node = astbuf2->clone();
 /////////
 
 wire_decl:
-	attr wire_type range {
+	attr wire_type range_or_multirange {
 		albuf = $1;
 		astbuf1 = $2;
 		astbuf2 = checkRange(astbuf1, $3);
+
+		if (astbuf2 && astbuf2->type == AST_MULTIRANGE) {
+			astbuf2->is_packed = true; // packed multirange
+		}
 	} delay wire_name_list {
 		delete astbuf1;
 		if (astbuf2 != NULL)
@@ -2553,6 +2568,20 @@ assert_property:
 		}
 	};
 
+local_definition_stmt:
+	non_io_wire_type TOK_ID '=' delay expr {
+		if (!sv_mode)
+			frontend_verilog_yyerror("Found variable declaration in for declaration (%s). This is not supported unless read_verilog is called with -sv!", $2->c_str());
+		astbuf3->str = *($2);
+		AstNode *node = new AstNode(AST_ASSIGN_EQ, astbuf3->clone(), $5);
+		delete astbuf3;
+		ast_stack.back()->children.push_back(node);
+		SET_AST_NODE_LOC(node, @2, @5);
+	};
+
+for_initialization:
+	 local_definition_stmt | simple_behavioral_stmt;
+
 simple_behavioral_stmt:
 	attr lvalue '=' delay expr {
 		AstNode *node = new AstNode(AST_ASSIGN_EQ, $2, $5);
@@ -2663,11 +2692,14 @@ behavioral_stmt:
 		ast_stack.pop_back();
 	} |
 	attr TOK_FOR '(' {
+		AstNode *block = new AstNode(AST_BLOCK);
 		AstNode *node = new AstNode(AST_FOR);
-		ast_stack.back()->children.push_back(node);
+		block->str = std::string("$loopvar$") + std::to_string(autoidx++);
+		block->children.push_back(node);
+		ast_stack.back()->children.push_back(block);
 		ast_stack.push_back(node);
 		append_attr(node, $1);
-	} simple_behavioral_stmt ';' expr {
+	} for_initialization ';' expr {
 		ast_stack.back()->children.push_back($7);
 	} ';' simple_behavioral_stmt ')' {
 		AstNode *block = new AstNode(AST_BLOCK);
@@ -2937,7 +2969,7 @@ gen_stmt:
 		AstNode *node = new AstNode(AST_GENFOR);
 		ast_stack.back()->children.push_back(node);
 		ast_stack.push_back(node);
-	} simple_behavioral_stmt ';' expr {
+	} for_initialization ';' expr {
 		ast_stack.back()->children.push_back($6);
 	} ';' simple_behavioral_stmt ')' gen_stmt_block {
 		SET_AST_NODE_LOC(ast_stack.back(), @1, @11);
@@ -3014,8 +3046,23 @@ expr:
 		$$->children.push_back($6);
 		SET_AST_NODE_LOC($$, @1, @$);
 		append_attr($$, $3);
+	} |
+	inside_begin inside_list '}' {
+		$$ = ast_stack.back()->children.back();
+		ast_stack.back()->children.pop_back();
+		SET_AST_NODE_LOC($$, @1, @2);
+	};
+
+inside_begin:
+	basic_expr TOK_INSIDE '{' {
+		ast_stack.back()->children.push_back(new AstNode(AST_INSIDE, $1));
 	};
 
+inside_list:
+	rvalue {
+		ast_stack.back()->children.back()->children.back()->children.push_back($1);
+	} | inside_list ',' inside_list;
+
 basic_expr:
 	rvalue {
 		$$ = $1;
diff --git a/kernel/constids.inc b/kernel/constids.inc
index 68d10def6..de05de101 100644
--- a/kernel/constids.inc
+++ b/kernel/constids.inc
@@ -135,6 +135,7 @@ X(OFFSET)
 X(onehot)
 X(P)
 X(parallel_case)
+X(partial)
 X(parameter)
 X(PORTID)
 X(PRIORITY)
@@ -142,6 +143,7 @@ X(PRIORITY_MASK)
 X(Q)
 X(qwp_position)
 X(R)
+X(multirange)
 X(RD_ADDR)
 X(RD_ARST)
 X(RD_ARST_VALUE)
diff --git a/tests/various/for_declaration.sv b/tests/various/for_declaration.sv
new file mode 100644
index 000000000..6794c46c3
--- /dev/null
+++ b/tests/various/for_declaration.sv
@@ -0,0 +1,93 @@
+module foo;
+`default_nettype none
+integer out;
+initial begin
+int i;
+i = 10;
+for (int i = 0; i < 5; i++)
+  out = i;
+out = i;
+end
+
+logic [7:0] outa = 8'b00000000;
+genvar a;
+for (a = 0 ; a < 8; a++) begin
+  assign outa[a] = 1'b1;
+end
+
+logic [6:0] outb = 7'b1111111;
+for (genvar b = 0 ; b < 7; b++) begin
+  assign outb[b] = 1'b0;
+end
+
+
+logic [5:0] outc = 6'b000000;
+always @(*) begin
+  for (int c = 0 ; c < 6; c++) begin
+    outc[c] = 1'b1;
+  end
+end
+
+logic [4:0] outd = 5'b11111;
+always @(*) begin
+  for (int unsigned d = 0 ; d < 5; d++) begin
+    outd[d] = 1'b0;
+  end
+end
+
+logic [3:0] oute = 4'b0000;
+always @(*) begin
+  for (int signed e = 0 ; e < 4; e++) begin
+    oute[e] = 1'b1;
+  end
+end
+
+logic x;
+for (genvar x = 0; x < 2; x++) begin : loop
+    logic [x:0] y;
+end
+assign x = 1'sb1;
+assign loop[0].y = 1'sb1;
+assign loop[1].y = 2'sb10;
+
+reg [15:0] k;
+if (1) begin : gen
+  integer k;
+  initial begin
+    for (integer k = 5; k < 10; k++)
+      if (k == 5)
+        gen.k = 0;
+      else
+        gen.k += 2 ** k;
+    k = k * 2;
+  end
+end
+initial k = gen.k;
+
+wire [3:0] l;
+for (genvar l = 0; l < 2; l++) begin : blk
+  localparam w = l;
+  if (l == 0) begin : sub
+    wire [w:0] l;
+  end
+end
+assign l = 2;
+assign blk[0].sub.l = 1;
+
+always_comb begin
+  assert(8'b11111111 == outa);
+  assert(7'b0000000 == outb);
+  assert(6'b111111 == outc);
+  assert(5'b00000 == outd);
+  assert(4'b1111 == oute);
+  assert(10 == out);
+  assert(1'sb1 == x);
+  assert(1'sb1 == loop[0].y);
+  assert(2'sb10 == loop[1].y);
+  assert(k == gen.k);
+  assert(k == 16'b0000011110000000);
+  assert(l == 2);
+  assert(blk[0].sub.l == 1);
+end
+
+endmodule
diff --git a/tests/various/for_declaration.ys b/tests/various/for_declaration.ys
new file mode 100644
index 000000000..ebbbcae68
--- /dev/null
+++ b/tests/various/for_declaration.ys
@@ -0,0 +1,4 @@
+read_verilog -sv for_declaration.sv
+hierarchy; proc; opt
+select -module foo
+sat -verify -seq 1 -tempinduct -prove-asserts -show-all
diff --git a/tests/various/for_declaration_sv_mode_generate.ys b/tests/various/for_declaration_sv_mode_generate.ys
new file mode 100644
index 000000000..84336955e
--- /dev/null
+++ b/tests/various/for_declaration_sv_mode_generate.ys
@@ -0,0 +1,6 @@
+logger -expect error "Found variable declaration in for declaration .*" 1
+read_verilog <<EOF
+module foo();
+for (genvar      x = 0; x < 1; x++) begin end
+endmodule
+EOF
diff --git a/tests/various/for_declaration_sv_mode_procedural.ys b/tests/various/for_declaration_sv_mode_procedural.ys
new file mode 100644
index 000000000..5d027f76b
--- /dev/null
+++ b/tests/various/for_declaration_sv_mode_procedural.ys
@@ -0,0 +1,8 @@
+logger -expect error "Found variable declaration in for declaration .*" 1
+read_verilog <<EOF
+module foo();
+always begin
+  for (integer      y = 0; y < 1; y++) begin end
+end
+endmodule
+EOF
diff --git a/tests/various/for_declaration_warnings.ys b/tests/various/for_declaration_warnings.ys
new file mode 100644
index 000000000..2e91b3232
--- /dev/null
+++ b/tests/various/for_declaration_warnings.ys
@@ -0,0 +1,17 @@
+logger -expect-no-warnings
+read_verilog -sv <<EOF
+module foo();
+always_comb begin
+  for (integer  x = 0; x < 1; x++) begin end
+  for (int      x = 0; x < 1; x++) begin end
+  for (shortint x = 0; x < 1; x++) begin end
+
+  integer x;
+  int y;
+  shortint z;
+  for (x = 0; x < 1; x++) begin end
+  for (y = 0; y < 1; y++) begin end
+  for (z = 0; z < 1; z++) begin end
+end
+endmodule
+EOF
