diff --git a/frontends/ast/genrtlil.cc b/frontends/ast/genrtlil.cc
index 1fe74bb72..63a64736f 100644
--- a/frontends/ast/genrtlil.cc
+++ b/frontends/ast/genrtlil.cc
@@ -849,6 +849,8 @@ void AstNode::detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *foun
 				while (id_ast->simplify(true, false, false, 1, -1, false, true)) { }
 			if (id_ast->children[0]->type == AST_CONSTANT)
 				this_width = id_ast->children[0]->bits.size();
+			else if (id_ast->children.size() == 1 && id_ast->children[0]->type == AST_IDENTIFIER && id_ast->children[0]->id2ast)
+				this_width = id_ast->children[0]->id2ast->range_left - id_ast->children[0]->id2ast->range_right + 1;
 			else
 				log_file_error(filename, location.first_line, "Failed to detect width for parameter %s!\n", str.c_str());
 			if (children.size() != 0)
@@ -877,7 +879,7 @@ void AstNode::detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *foun
 			this_width = id_ast->children[0]->range_left - id_ast->children[0]->range_right + 1;
 			if (children.size() > 1)
 				range = children[1];
-		} else if (id_ast->type == AST_STRUCT_ITEM) {
+		} else if (id_ast->type == AST_STRUCT_ITEM || id_ast->type == AST_STRUCT) {
 			AstNode *tmp_range = make_struct_member_range(this, id_ast);
 			this_width = tmp_range->range_left - tmp_range->range_right + 1;
 			delete tmp_range;
diff --git a/frontends/ast/simplify.cc b/frontends/ast/simplify.cc
index cb47e641a..f03a88278 100644
--- a/frontends/ast/simplify.cc
+++ b/frontends/ast/simplify.cc
@@ -300,6 +300,21 @@ static int size_packed_struct(AstNode *snode, int base_offset)
 	bool is_union = (snode->type == AST_UNION);
 	int offset = 0;
 	int packed_width = -1;
+	// embeded struct or union with range?
+	auto it = std::remove_if(snode->children.begin(), snode->children.end(),
+                         [](AstNode* node) { return node->type == AST_RANGE; });
+	std::vector<AstNode*> ranges(it, snode->children.end());
+	snode->children.erase(it, snode->children.end());
+	if (!ranges.empty()) {
+		if (ranges.size() > 1) {
+			log_file_error(ranges[1]->filename, ranges[1]->location.first_line, "Currently support for custom-type with range is limited to single range\n");
+		}
+		for (auto range : ranges) {
+			snode->multirange_dimensions.push_back(min(range->range_left, range->range_right));
+			snode->multirange_dimensions.push_back(max(range->range_left, range->range_right) - min(range->range_left, range->range_right) + 1);
+			snode->multirange_swapped.push_back(range->range_swapped);
+		}
+	}
 	// examine members from last to first
 	for (auto it = snode->children.rbegin(); it != snode->children.rend(); ++it) {
 		auto node = *it;
@@ -307,6 +322,15 @@ static int size_packed_struct(AstNode *snode, int base_offset)
 		if (node->type == AST_STRUCT || node->type == AST_UNION) {
 			// embedded struct or union
 			width = size_packed_struct(node, base_offset + offset);
+			if (!node->multirange_dimensions.empty()) {
+				int number_of_structs = 1;
+				number_of_structs = node->multirange_dimensions.back();
+				width *= number_of_structs;
+			}
+			// set range of struct
+			node->range_right = base_offset + offset;
+			node->range_left = base_offset + offset + width - 1;
+			node->range_valid = true;
 		}
 		else {
 			log_assert(node->type == AST_STRUCT_ITEM);
@@ -493,14 +517,12 @@ static void add_members_to_scope(AstNode *snode, std::string name)
 	// in case later referenced in assignments
 	log_assert(snode->type==AST_STRUCT || snode->type==AST_UNION);
 	for (auto *node : snode->children) {
+		auto member_name = name + "." + node->str;
+		current_scope[member_name] = node;
 		if (node->type != AST_STRUCT_ITEM) {
 			// embedded struct or union
 			add_members_to_scope(node, name + "." + node->str);
 		}
-		else {
-			auto member_name = name + "." + node->str;
-			current_scope[member_name] = node;
-		}
 	}
 }
 
@@ -509,7 +531,7 @@ static int get_max_offset(AstNode *node)
 	// get the width from the MS member in the struct
 	// as members are laid out from left to right in the packed wire
 	log_assert(node->type==AST_STRUCT || node->type==AST_UNION);
-	while (node->type != AST_STRUCT_ITEM) {
+	while (node->range_left < 0) {
 		node = node->children[0];
 	}
 	return node->range_left;
@@ -673,6 +695,108 @@ void add_wire_for_ref(const RTLIL::Wire *ref, const std::string &str)
 	current_scope[str] = wire;
 }
 
+// try to remove and delete an attribute, and return whether it existed
+static bool consume_attribute(AstNode* node, const std::string& attr)
+{
+	auto it = node->attributes.find(attr);
+	if (it == node->attributes.end())
+		return false;
+	delete it->second;
+	node->attributes.erase(it);
+	return true;
+}
+
+// After unrolling a procedural loop, we generate a procedural assignment for
+// the ending value of the loop variable. However, if the loop variable is local
+// and unused, we'd like to remove this unneeded assignment, especially to avoid
+// an errant inferred latch in an `always_comb` block. To accomplish this, we
+// first mark loop variables and their corresponding "lvers" with this attribute
+// during unrolling. Then, after the module has been processed, we traverse the
+// AST, and, if no other identifier besides the one in the lver references the
+// loop variable, the lver is removed.
+static const std::string lver_attr = "\\LoopVariableEndingAssignment";
+
+// This is the core AST traversal for the above transformation. See `lver_attr`
+// and `remove_unneeded_lvers`.
+static void lver_traversal(std::map<std::string, AstNode*>& pending, AstNode* node) {
+	const std::string* should_mark_asgn = nullptr;
+
+	// loop var ending assigns replace the wire corresponding in the map if
+	// it hasn't already been invalidated
+	if (node->type == AST_ASSIGN_EQ && consume_attribute(node, lver_attr)) {
+		const std::string& var_id = node->children.at(0)->str;
+		// the var will be un-marked when the identifier in this assign is
+		// visited; it is safe to assume that is the only use of *this* var
+		// in the assign, but perhaps others might be seen, e.g., in a range
+		if (pending.at(var_id))
+			should_mark_asgn = &var_id;
+	}
+
+	// any usage of a pending identifier invalidates the removal
+	else if (node->type == AST_IDENTIFIER) {
+		auto it = pending.find(node->str);
+		if (it != pending.end())
+			it->second = nullptr;
+	}
+
+	for (AstNode* child : node->children)
+		lver_traversal(pending, child);
+
+	// if this is an ending assign pointer which hasn't been invalidated,
+	// update the mark to point to this node so it can be removed at the end
+	if (should_mark_asgn)
+		pending[*should_mark_asgn] = node;
+}
+
+// This is used after simplify()ing modules to remove assignments to loop vars
+// which aren't necessary because the loop var itself is never used.
+static void remove_unneeded_lvers(AstNode* root)
+{
+	std::map<std::string, AstNode*> pending;
+
+	// find any wires which have been marked as procedural loop vars
+	for (AstNode* node : root->children)
+		if (node->type == AST_WIRE && consume_attribute(node, lver_attr))
+			pending[node->str] = node;
+	if (!pending.size())
+		return;
+
+	// the "pending" elements in the map are replaced by the corresponding
+	// procedural assignment so long as no identifiers besides the one it
+	// contains references the corresponding loop variable
+	lver_traversal(pending, root);
+
+	// remove the identified unneeded assignments
+	for (auto& elem : pending) {
+		AstNode* node = elem.second;
+		// if the variable is only used in the lver
+		if (node && node->type == AST_ASSIGN_EQ) {
+			// remove the asgn by making it a silly stub node in place
+			node->delete_children();
+			node->type = AST_BLOCK;
+		}
+	}
+}
+
+// Used during loop unrolling to appropriately mark relevant nodes for the above
+// function remove_unneeded_lvers().
+static void mark_lver(AstNode* asgn)
+{
+	log_assert(asgn->type == AST_ASSIGN_EQ);
+	AstNode* wire = asgn->children.at(0)->id2ast;
+	log_assert(wire->type == AST_WIRE);
+
+	// don't try to handle reused loop variables
+	if (wire->attributes.count(lver_attr))
+		return;
+
+	if (wire->str.find("$fordecl_block") != std::string::npos ||
+			wire->str.find("$unnamed_block") != std::string::npos) {
+		asgn->attributes[lver_attr] = AstNode::mkconst_int(1, false);
+		wire->attributes[lver_attr] = AstNode::mkconst_int(1, false);
+	}
+}
+
 // convert the AST into a simpler AST that has all parameters substituted by their
 // values, unrolled for-loops, expanded generate blocks, etc. when this function
 // is done with an AST it can be converted into RTLIL using genRTLIL().
@@ -980,6 +1104,8 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 				}
 			}
 		}
+
+		remove_unneeded_lvers(this);
 	}
 
 	// create name resolution entries for all objects with names
@@ -1224,6 +1350,13 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 
 	case AST_PARAMETER:
 	case AST_LOCALPARAM:
+		if (children[0]->type == AST_IDENTIFIER && current_scope.count(children[0]->str) > 0) {
+			auto item_node = current_scope[children[0]->str];
+			if (item_node->type == AST_STRUCT || item_node->type == AST_UNION) {
+				attributes[ID::wiretype] = item_node->clone();
+				add_members_to_scope(attributes[ID::wiretype], str);
+			}
+		}
 		while (!children[0]->basic_prep && children[0]->simplify(false, false, false, stage, -1, false, true) == true)
 			did_something = true;
 		children[0]->detectSignWidth(width_hint, sign_hint);
@@ -1901,7 +2034,7 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 		if (name_has_dot(str, sname)) {
 			if (current_scope.count(str) > 0) {
 				auto item_node = current_scope[str];
-				if (item_node->type == AST_STRUCT_ITEM) {
+				if (item_node->type == AST_STRUCT_ITEM || item_node->type == AST_STRUCT) {
 					// structure member, rewrite this node to reference the packed struct wire
 					auto range = make_struct_member_range(this, item_node);
 					newNode = new AstNode(AST_IDENTIFIER, range);
@@ -2200,6 +2333,7 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 			delete buf->children[1];
 			buf->children[1] = varbuf->children[0]->clone();
 			current_block->children.insert(current_block->children.begin() + current_block_idx++, buf);
+			mark_lver(buf);
 		}
 
 		current_scope[varbuf->str] = backup_scope_varbuf;
diff --git a/tests/simple/loop_var_keep.sv b/tests/simple/loop_var_keep.sv
new file mode 100644
index 000000000..fb73683a7
--- /dev/null
+++ b/tests/simple/loop_var_keep.sv
@@ -0,0 +1,14 @@
+module top (
+    input logic inp,
+    output logic [4:0] out
+);
+    always @* begin
+        out = 0;
+        if (inp) begin
+            int i;
+            for (i = 0; i < 5; i++)
+                out[i] = 1'b1;
+            out[i - 1] = 1'b0;
+        end
+    end
+endmodule
diff --git a/tests/simple/loop_var_no_latch_1.sv b/tests/simple/loop_var_no_latch_1.sv
new file mode 100644
index 000000000..1b442d3ce
--- /dev/null
+++ b/tests/simple/loop_var_no_latch_1.sv
@@ -0,0 +1,13 @@
+module top (
+    input logic inp,
+    output logic [4:0] out
+);
+    always_comb begin
+        out = 0;
+        if (inp) begin
+            int i;
+            for (i = 0; i < 5; i++)
+                out[i] = 1'b1;
+        end
+    end
+endmodule
diff --git a/tests/simple/loop_var_no_latch_2.sv b/tests/simple/loop_var_no_latch_2.sv
new file mode 100644
index 000000000..5d26bbd19
--- /dev/null
+++ b/tests/simple/loop_var_no_latch_2.sv
@@ -0,0 +1,12 @@
+module top (
+    input logic inp,
+    output logic [4:0] out
+);
+    always_comb begin
+        out = 0;
+        if (inp) begin
+            for (int i = 0; i < 5; i++)
+                out[i] = 1'b1;
+        end
+    end
+endmodule
diff --git a/tests/various/param_struct.ys b/tests/various/param_struct.ys
index 6d7a7c6ad..b8de67968 100644
--- a/tests/various/param_struct.ys
+++ b/tests/various/param_struct.ys
@@ -41,8 +41,7 @@ always_comb begin
   assert(j == 1'b1);
   assert(k == 1'b0);
   assert(l == 3'b111);
-// TODO: support access to whole sub-structs and unions
-//  assert(m == 2'b10);
+  assert(m == 2'b10);
   assert(u == 5'b11001);
 end
 endmodule
diff --git a/tests/various/struct_access.ys b/tests/various/struct_access.ys
new file mode 100644
index 000000000..d89775443
--- /dev/null
+++ b/tests/various/struct_access.ys
@@ -0,0 +1,43 @@
+read_verilog -sv -dump_ast1 -dump_ast2 << EOF
+module dut();
+typedef struct packed {
+  logic a;
+  logic b;
+} struct_t;
+
+typedef struct packed {
+  struct_t c;
+} sub_struct_t;
+
+typedef struct packed {
+  sub_struct_t d;
+  sub_struct_t e;
+} sub_sub_struct_t;
+
+parameter sub_sub_struct_t P = 4'b1100;
+
+localparam sub_struct_t f = P.d;
+localparam sub_struct_t g = P.e;
+localparam struct_t h = f.c;
+localparam logic i = P.d.c.a;
+localparam logic j = P.d.c.b;
+localparam x = P.e;
+localparam y = x.c;
+localparam z = y.a;
+
+always_comb begin
+  assert(P == 4'b1100);
+  assert(f == 2'b11);
+  assert(g == 2'b00);
+  assert(h == 2'b11);
+  assert(i == 1'b1);
+  assert(j == 1'b1);
+  assert(x == 2'b00);
+  assert(y == 2'b00);
+  assert(z == 1'b0);
+end
+endmodule
+EOF
+hierarchy; proc; opt
+sat -verify -seq 1 -tempinduct -prove-asserts -show-all
+
diff --git a/tests/verilog/struct_access.sv b/tests/verilog/struct_access.sv
index f13b8dd51..bc91e3f01 100644
--- a/tests/verilog/struct_access.sv
+++ b/tests/verilog/struct_access.sv
@@ -77,9 +77,8 @@ module top;
         `CHECK(s.y.a, 1, 0)
         `CHECK(s.y.b, 1, 1)
 
-        // TODO(zachjs): support access to whole sub-structs and unions
-        // `CHECK(s.x, 2, 0)
-        // `CHECK(s.y, 2, 1)
+        `CHECK(s.x, 2, 0)
+        `CHECK(s.y, 2, 1)
 
         assert (fail === 0);
     end
