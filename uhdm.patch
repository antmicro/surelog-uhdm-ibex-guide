diff --git a/Makefile b/Makefile
index 5b7dd169c..704535bac 100644
--- a/Makefile
+++ b/Makefile
@@ -592,6 +592,7 @@ $(eval $(call add_include_file,libs/json11/json11.hpp))
 $(eval $(call add_include_file,passes/fsm/fsmdata.h))
 $(eval $(call add_include_file,frontends/ast/ast.h))
 $(eval $(call add_include_file,frontends/ast/ast_binding.h))
+$(eval $(call add_include_file,frontends/verilog/verilog_frontend.h))
 $(eval $(call add_include_file,frontends/blif/blifparse.h))
 $(eval $(call add_include_file,backends/rtlil/rtlil_backend.h))
 $(eval $(call add_include_file,backends/cxxrtl/cxxrtl.h))
diff --git a/frontends/ast/ast.cc b/frontends/ast/ast.cc
index 4fbc238b0..818756e26 100644
--- a/frontends/ast/ast.cc
+++ b/frontends/ast/ast.cc
@@ -214,6 +214,7 @@ AstNode::AstNode(AstNodeType type, AstNode *child1, AstNode *child2, AstNode *ch
 	is_signed = false;
 	is_string = false;
 	is_enum = false;
+	is_packed = false;
 	is_wand = false;
 	is_wor = false;
 	is_unsized = false;
@@ -275,12 +276,38 @@ void AstNode::delete_children()
 	attributes.clear();
 }
 
+AstNode* AstNode::find_child(const std::string& name)
+{
+	for (auto child : children) {
+		if (child->str == name) {
+			return child;
+		}
+	}
+	return nullptr;
+}
+
+AstNode* AstNode::find_child(AstNodeType type, const std::string& name)
+{
+	auto child = find_child(name);
+	if (child && child->type == type) {
+		return child;
+	}
+	return nullptr;
+}
+
 // AstNode destructor
 AstNode::~AstNode()
 {
 	delete_children();
 }
 
+void AstNode::visitEachDescendant(const std::function<void(AST::AstNode*)>& f) {
+	for (auto child : children) {
+		f(child);
+		child->visitEachDescendant(f);
+	}
+}
+
 // create a nice text representation of the node
 // (traverse tree by recursion, use 'other' pointer for diffing two AST trees)
 void AstNode::dumpAst(FILE *f, std::string indent) const
@@ -351,6 +378,9 @@ void AstNode::dumpAst(FILE *f, std::string indent) const
 	if (is_enum) {
 		fprintf(f, " type=enum");
 	}
+	if (is_packed) {
+		fprintf(f, " packed");
+	}
 	fprintf(f, "\n");
 
 	for (auto &it : attributes) {
@@ -766,6 +796,14 @@ AstNode *AstNode::mkconst_int(uint32_t v, bool is_signed, int width)
 	return node;
 }
 
+// create an AST node for a real constant
+AstNode *AstNode::mkconst_real(double v)
+{
+	AstNode *node = new AstNode(AST_REALVALUE);
+	node->realvalue = v;
+	return node;
+}
+
 // create an AST node for a constant (using a bit vector as value)
 AstNode *AstNode::mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsized)
 {
@@ -1364,15 +1402,6 @@ std::pair<std::string,std::string> AST::split_modport_from_type(std::string name
 
 }
 
-AstNode * AST::find_modport(AstNode *intf, std::string name)
-{
-	for (auto &ch : intf->children)
-		if (ch->type == AST_MODPORT)
-			if (ch->str == name) // Modport found
-				return ch;
-	return NULL;
-}
-
 // Iterate over all wires in an interface and add them as wires in the AST module:
 void AST::explode_interface_port(AstNode *module_ast, RTLIL::Module * intfmodule, std::string intfname, AstNode *modport)
 {
@@ -1460,9 +1489,8 @@ void AstModule::reprocess_module(RTLIL::Design *design, const dict<RTLIL::IdStri
 							RTLIL::Module *intfmodule = design->module(interface_type); // All interfaces should at this point in time (assuming
 							                                                              // reprocess_module is called from the hierarchy pass) be
 							                                                              // present in design->modules_
-							AstModule *ast_module_of_interface = (AstModule*)intfmodule;
 							std::string interface_modport_compare_str = "\\" + interface_modport;
-							AstNode *modport = find_modport(ast_module_of_interface->ast, interface_modport_compare_str); // modport == NULL if no modport
+							AstNode *modport = ast->find_child(AST::AST_MODPORT, interface_modport_compare_str); // modport == NULL if no modport
 							// Iterate over all wires in the interface and add them to the module:
 							explode_interface_port(new_ast, intfmodule, name_port, modport);
 						}
@@ -1538,7 +1566,7 @@ RTLIL::IdString AstModule::derive(RTLIL::Design *design, const dict<RTLIL::IdStr
 				std::string interface_modport = modports.at(intfname).str();
 				AstModule *ast_module_of_interface = (AstModule*)intfmodule;
 				AstNode *ast_node_of_interface = ast_module_of_interface->ast;
-				modport = find_modport(ast_node_of_interface, interface_modport);
+				modport = ast_node_of_interface->find_child(AST::AST_MODPORT, interface_modport);
 			}
 			// Iterate over all wires in the interface and add them to the module:
 			explode_interface_port(new_ast, intfmodule, intfname, modport);
diff --git a/frontends/ast/ast.h b/frontends/ast/ast.h
index 63104bca4..7663e2737 100644
--- a/frontends/ast/ast.h
+++ b/frontends/ast/ast.h
@@ -200,6 +200,8 @@ namespace AST
 		double realvalue;
 		// set for IDs typed to an enumeration, not used
 		bool is_enum;
+		// for AST_RANGES
+		bool is_packed;
 
 		// if this is a multirange memory then this vector contains offset and length of each dimension
 		std::vector<int> multirange_dimensions;
@@ -225,6 +227,8 @@ namespace AST
 		AstNode *clone() const;
 		void cloneInto(AstNode *other) const;
 		void delete_children();
+		AstNode* find_child(const std::string& name);
+		AstNode* find_child(AstNodeType type, const std::string& name);
 		~AstNode();
 
 		enum mem2reg_flags
@@ -286,6 +290,8 @@ namespace AST
 
 		// Generate RTLIL for a bind construct
 		std::vector<RTLIL::Binding *> genBindings() const;
+		// Visit each descendant of this node and call the passed function on it
+		void visitEachDescendant(const std::function<void(AST::AstNode*)>& f);
 
 		// used by genRTLIL() for detecting expression width and sign
 		void detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *found_real = NULL);
@@ -304,6 +310,7 @@ namespace AST
 
 		// helper functions for creating AST nodes for constants
 		static AstNode *mkconst_int(uint32_t v, bool is_signed, int width = 32);
+		static AstNode *mkconst_real(double v);
 		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsized);
 		static AstNode *mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed);
 		static AstNode *mkconst_str(const std::vector<RTLIL::State> &v);
@@ -376,7 +383,7 @@ namespace AST
 	void set_src_attr(RTLIL::AttrObject *obj, const AstNode *ast);
 
 	// struct helper exposed from simplify for genrtlil
-	AstNode *make_struct_member_range(AstNode *node, AstNode *member_node);
+	AstNode *make_struct_member_range(AstNode *node, AstNode *member_node, int move = 0);
 }
 
 namespace AST_INTERNAL
diff --git a/frontends/ast/simplify.cc b/frontends/ast/simplify.cc
index 607ca9a8b..71cc545c7 100644
--- a/frontends/ast/simplify.cc
+++ b/frontends/ast/simplify.cc
@@ -31,6 +31,7 @@
 #include "frontends/verilog/verilog_frontend.h"
 #include "ast.h"
 
+#include <algorithm>
 #include <sstream>
 #include <stdarg.h>
 #include <stdlib.h>
@@ -238,12 +239,17 @@ void AstNode::annotateTypedEnums(AstNode *template_node)
 	}
 }
 
-static bool name_has_dot(const std::string &name, std::string &struct_name)
+static bool name_has_dot(const std::string &name, std::string &struct_name, std::string &struct_field)
 {
 	// check if plausible struct member name \sss.mmm
-	std::string::size_type pos;
-	if (name.substr(0, 1) == "\\" && (pos = name.find('.', 0)) != std::string::npos) {
+	std::string::size_type start_pos = name.rfind(']');
+	if(start_pos == std::string::npos)
+		start_pos = 0;
+
+	std::string::size_type pos = name.find('.', start_pos);
+	if (name.substr(0, 1) == "\\" && (pos != std::string::npos)) {
 		struct_name = name.substr(0, pos);
+		struct_field = name.substr(pos); // return str with . at begining
 		return true;
 	}
 	return false;
@@ -307,9 +313,14 @@ static int size_packed_struct(AstNode *snode, int base_offset)
 		if (node->type == AST_STRUCT || node->type == AST_UNION) {
 			// embedded struct or union
 			width = size_packed_struct(node, base_offset + offset);
+			// set range of struct
+			node->range_right = base_offset + offset;
+			node->range_left = base_offset + offset + width - 1;
+			node->range_valid = true;
 		}
 		else {
 			log_assert(node->type == AST_STRUCT_ITEM);
+			while(node->simplify(false, false,false, 1, -1, false, false)) { }
 			if (node->children.size() > 0 && node->children[0]->type == AST_RANGE) {
 				// member width e.g. bit [7:0] a
 				width = range_width(node, node->children[0]);
@@ -351,6 +362,9 @@ static int size_packed_struct(AstNode *snode, int base_offset)
 					delete child;
 				node->children.clear();
 			}
+			else if (node->children.size() == 1 && node->children[0]->type == AST_ENUM) {
+				width = node->children[0]->children[0]->range_left - node->children[0]->children[0]->range_right + 1;
+			}
 			else if (node->range_left < 0) {
 				// 1 bit signal: bit, logic or reg
 				width = 1;
@@ -456,7 +470,7 @@ static AstNode *slice_range(AstNode *rnode, AstNode *snode)
 }
 
 
-AstNode *AST::make_struct_member_range(AstNode *node, AstNode *member_node)
+AstNode *AST::make_struct_member_range(AstNode *node, AstNode *member_node, int move)
 {
 	// Work out the range in the packed array that corresponds to a struct member
 	// taking into account any range operations applicable to the current node
@@ -465,18 +479,18 @@ AstNode *AST::make_struct_member_range(AstNode *node, AstNode *member_node)
 	int range_right = member_node->range_right;
 	if (node->children.empty()) {
 		// no range operations apply, return the whole width
-		return make_range(range_left, range_right);
+		return make_range(range_left + move, range_right + move);
 	}
 	int stride = get_struct_array_width(member_node);
 	if (node->children.size() == 1 && node->children[0]->type == AST_RANGE) {
 		// bit or array indexing e.g. s.a[2] or s.a[1:0]
-		return make_struct_index_range(node, node->children[0], stride, range_right);
+		return make_struct_index_range(node, node->children[0], stride, range_right + move);
 	}
 	else if (node->children.size() == 1 && node->children[0]->type == AST_MULTIRANGE) {
 		// multirange, i.e. bit slice after array index, e.g. s.a[i][p:q]
 		log_assert(stride > 1);
 		auto mrnode = node->children[0];
-		auto element_range = make_struct_index_range(node, mrnode->children[0], stride, range_right);
+		auto element_range = make_struct_index_range(node, mrnode->children[0], stride, range_right + move);
 		// then apply bit slice range
 		auto range = slice_range(element_range, mrnode->children[1]);
 		delete element_range;
@@ -497,10 +511,8 @@ static void add_members_to_scope(AstNode *snode, std::string name)
 			// embedded struct or union
 			add_members_to_scope(node, name + "." + node->str);
 		}
-		else {
-			auto member_name = name + "." + node->str;
-			current_scope[member_name] = node;
-		}
+		auto member_name = name + "." + node->str;
+		current_scope[member_name] = node;
 	}
 }
 
@@ -564,6 +576,85 @@ static std::string prefix_id(const std::string &prefix, const std::string &str)
 	return prefix + str;
 }
 
+static void flatten_ranges(AstNode *node)
+{
+	if ((node->children.size() <= 1)) {
+		return;
+	}
+
+	unsigned ranges = std::count_if(node->children.begin(),
+			node->children.end(),
+			[](AstNode *n){return n->type == AST_RANGE;});
+
+	if (ranges <= 1) {
+		return;
+	}
+
+	int size = 1;
+	// count size of vector (width)
+	for (const auto& itr : node->children) {
+		if (itr->type != AST_RANGE)
+			continue;
+
+		const int width = itr->range_left - itr->range_right + 1;
+		size *= width;
+	}
+
+	// remove ranges
+	size_t i = 0;
+	while(i < node->children.size())
+	{
+		if (node->children[i]->type != AST_RANGE){
+			i++;
+			continue;
+		}
+		delete *(node->children.begin() + i);
+		node->children.erase(node->children.begin() + i);
+	}
+
+	// Place new one-dimensional range (packed vector)
+	AstNode* simple_range = new AstNode(AST_RANGE);
+	simple_range->integer = size;
+	simple_range->children.push_back(node->mkconst_int(size - 1, false, 32));
+	simple_range->children.push_back(node->mkconst_int(0, false, 32));
+	node->children.push_back(simple_range);
+}
+
+static bool make_mutliranges(AstNode *node, bool packed = false)
+{
+	if ((node->children.size() <= 1)) {
+		return false;
+	}
+
+	unsigned ranges = std::count_if(node->children.begin(),
+			node->children.end(),
+			[](AstNode *n){return n->type == AST_RANGE;});
+
+	if (ranges <= 1) {
+		return false;
+	}
+
+	AstNode* simple_multirange = new AstNode(AST_MULTIRANGE);
+	// remove ranges
+	size_t i = 0;
+	while(i < node->children.size())
+	{
+		if (node->children[i]->type != AST_RANGE){
+			i++;
+			continue;
+		}
+		simple_multirange->children.push_back(node->children[i]->clone());
+		delete *(node->children.begin() + i);
+		node->children.erase(node->children.begin() + i);
+	}
+
+	// Place new one-dimensional range (packed vector)
+	simple_multirange->integer = ranges;
+	simple_multirange->is_packed = packed;
+	node->children.push_back(simple_multirange);
+	return true;
+}
+
 // convert the AST into a simpler AST that has all parameters substituted by their
 // values, unrolled for-loops, expanded generate blocks, etc. when this function
 // is done with an AST it can be converted into RTLIL using genRTLIL().
@@ -981,6 +1072,65 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 					log_warning("reg '%s' is assigned in a continuous assignment at %s.\n", children[0]->str.c_str(), loc_string().c_str());
 			}
 			children[0]->was_checked = true;
+
+			// assigning multirange arrays?
+			if (children.size() >= 2 && current_scope.count(children[0]->str) > 0 && current_scope.count(children[1]->str) > 0) {
+				const auto* lhs = current_scope.at(children[0]->str);
+				const auto* rhs = current_scope.at(children[1]->str);
+
+				const auto lhs_range = lhs->range_left - lhs->range_right + 1;
+
+				// Apply workaround only for port wire
+				if ((lhs && (lhs->port_id > 0)) || (rhs && (rhs->port_id > 0))) {
+					int ranges[2] = {0};
+
+					if (lhs) {
+						for (const auto* node : lhs->children) {
+							if (node->type == AST_RANGE)
+								ranges[0] += 1;
+						}
+					}
+
+					if (rhs) {
+						for (const auto* node : rhs->children) {
+							if (node->type == AST_RANGE)
+								ranges[1] += 1;
+						}
+					}
+
+					if ((ranges[0] == 1) && (ranges[1] == 2)) {
+						// assign a = b;
+						if ((children[0]->children.size() == 0) && (children[1]->children.size() == 0)) {
+
+							AstNode* rhs = new AstNode;
+							rhs->type = AST_CONCAT;
+							int number_of_nodes = lhs_range / lhs->children[0]->integer; //TODO: is this good way to store size of array?
+							for (int i = 0 ; i < number_of_nodes ; ++i) {
+								AstNode* temp = new AstNode;
+								temp->type = AST_IDENTIFIER;
+								temp->str = children[1]->str;
+
+								temp->children.push_back(new AstNode);
+								temp->children[0]->type = AST_RANGE;
+								temp->children[0]->integer = i;
+								temp->children[0]->children.push_back(new AstNode);
+								temp->children[0]->children[0]->type = AST_CONSTANT;
+								temp->children[0]->children[0]->integer = i;
+
+								//while (temp->simplify(const_fold, at_zero, in_lvalue, stage, width_hint, sign_hint, in_param)) {};
+
+								rhs->children.push_back(temp);
+							}
+
+							children[1] = rhs; // memory leak
+							//while (rhs->simplify(const_fold, at_zero, in_lvalue, stage, width_hint, sign_hint, in_param)) {};
+							did_something = true;
+							//return true;
+						} // else (unsupported assignment)
+					}
+				}
+				// TODO: Other way around, e.g. multi <= single (needed e.g. in upper-hier. level module)
+			}
 		}
 		break;
 
@@ -1083,6 +1233,10 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 	case AST_SHIFT_RIGHT:
 	case AST_SHIFT_SLEFT:
 	case AST_SHIFT_SRIGHT:
+		log_assert(children.size() > 1);
+		// 11.4.10 Shift operators
+		// The right operand is always treated as an unsigned number
+		children[1]->is_signed = false;
 	case AST_POW:
 		detect_width_simple = true;
 		child_1_is_self_determined = true;
@@ -1189,6 +1343,7 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 
 	if (const_fold && type == AST_CASE)
 	{
+		while (children[0]->simplify(const_fold, at_zero, in_lvalue, stage, width_hint, sign_hint, in_param)) { }
 		int width_hint;
 		bool sign_hint;
 		detectSignWidth(width_hint, sign_hint);
@@ -1413,10 +1568,31 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 			if (template_node->type == AST_STRUCT || template_node->type == AST_UNION) {
 				// replace with wire representing the packed structure
 				newNode = make_packed_struct(template_node, str);
-				// add original input/output attribute to resolved wire
+				if (children.size() == 2 && children[1]->type == AST_RANGE && port_id == 0 && type == AST_WIRE) {
+					if(!make_mutliranges(this, true)){
+						constexpr int has_unpacked_range = 1;
+						newNode->attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
+						newNode->attributes[ID::wiretype]->children.push_back(children[1]->clone()); // save unpacked size
+						newNode->attributes[ID::wiretype]->is_packed= has_unpacked_range;
+					}
+ 					int s = std::abs(int(children[1]->children[0]->integer - children[1]->children[1]->integer)) + 1;
+ 					newNode->children[0]->range_left = (newNode->children[0]->range_left + 1) * s;
+ 					newNode->children[0]->children[0]->integer = (newNode->children[0]->children[0]->integer + 1) * s;
+ 					newNode->children[0]->range_left -= 1;
+ 					newNode->children[0]->children[0]->integer -= 1;
+
+				} else if(children.size() == 2 && children[1]->type == AST_RANGE) {
+					constexpr int has_unpacked_range = 1;
+					newNode->attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
+					newNode->attributes[ID::wiretype]->children.push_back(children[1]->clone()); // save unpacked size
+					newNode->attributes[ID::wiretype]->is_packed = has_unpacked_range;
+					newNode->children.push_back(children[1]->clone());
+				}
 				newNode->is_input = this->is_input;
 				newNode->is_output = this->is_output;
 				current_scope[str] = this;
+				newNode->port_id = this->port_id;
+				newNode->type = this->type;
 				goto apply_newNode;
 			}
 
@@ -1437,14 +1613,38 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 			range_left = template_node->range_left;
 			range_right = template_node->range_right;
 
-			attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
 
 			// if an enum then add attributes to support simulator tracing
 			annotateTypedEnums(template_node);
 
+			const bool wire_has_range = children.size() == 1 && children[0]->type == AST_RANGE && this->type != AST_MEMORY;
+			const int range_span = wire_has_range ? children[0]->children[1]->integer + 1 : 1;
+			if(range_span > 1)
+			{
+				delete children[0];
+				children.pop_back();
+			}
+
 			// Insert clones children from template at beginning
-			for (int i  = 0; i < GetSize(template_node->children); i++)
-				children.insert(children.begin() + i, template_node->children[i]->clone());
+			for (int i  = 0; i < GetSize(template_node->children); i++) {
+				if (template_node->children[i]->type == AST_RANGE && range_span > 1) {
+					auto *clone = template_node->children[i]->clone();
+					int size = clone->range_left - clone->range_right + 1;
+					clone->range_left = size * range_span - 1;
+					clone->children[0]->integer = clone->range_left;
+					range_left = clone->range_left;
+					children.insert(children.begin() + i, clone);
+				} else {
+					children.insert(children.begin() + i, template_node->children[i]->clone());
+				}
+			}
+			if(type != AST_MEMORY){
+				if(!make_mutliranges(this, true))
+				{
+					attributes[ID::wiretype] = mkconst_str(resolved_type_node->str);
+					attributes[ID::wiretype]->is_packed= wire_has_range;
+				}
+			}
 
 			if (type == AST_MEMORY && GetSize(children) == 1) {
 				// Single-bit memories must have [0:0] range
@@ -1453,6 +1653,51 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 			}
 			did_something = true;
 		}
+
+		// Convert only port wires
+		if ((port_id > 0)) {
+			flatten_ranges(this);
+		}
+
+		// FIXME: Basically same thing as above, should be merged
+		if (children.size() == 1 && children[0]->type == AST_MULTIRANGE && children[0]->is_packed) {
+			const auto* multirange = children[0];
+			const size_t ranges = std::count_if(
+				multirange->children.begin(), multirange->children.end(),
+				[](const AstNode* node) {
+					return node->type == AST_RANGE;
+				});
+			// More than two dimensions should be supported, but tested only 2.
+			if ((ranges == multirange->children.size())) {
+				size_t size = 1;
+
+				auto* attr_ranges = new AstNode;
+				attr_ranges->type = AST_CONSTANT;
+
+				for (const auto& itr : multirange->children) {
+					log_assert(itr->type == AST_RANGE);
+					const auto width = itr->range_left - itr->range_right + 1;
+					size *= width;
+					attr_ranges->children.push_back(itr->clone());
+				}
+				attr_ranges->range_left  = size - 1;
+				attr_ranges->range_right = 0;
+				attributes[ID::multirange] = attr_ranges;
+
+				// Replace with one-dimensional range (packed vector)
+				AstNode* simple_range = new AstNode(AST_RANGE);
+				simple_range->integer = size;
+				simple_range->children.push_back(mkconst_int(size - 1, false, 32));
+				simple_range->children.push_back(mkconst_int(0, false, 32));
+				delete children[0];
+				children.clear();
+				children.push_back(simple_range);
+
+				is_packed = true;
+				did_something = true;
+			}
+		}
+
 		log_assert(!is_custom_type);
 	}
 
@@ -1489,6 +1734,59 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 				children.push_back(template_child->clone());
 			did_something = true;
 		}
+
+		// FIXME: move to separate function
+		for (size_t i = 0 ; i < children.size() ; ++i) {
+			if (children[i]->type == AST_MULTIRANGE) {// && children[i]->is_packed) {
+			//if (children[i]->type == AST_MULTIRANGE && attributes.count(ID::multirange) == 0) {// && children[i]->is_packed) {
+				const auto* multirange = children[i];
+				const size_t ranges = std::count_if(
+					multirange->children.begin(), multirange->children.end(),
+					[](const AstNode* node) {
+						return node->type == AST_RANGE;
+					});
+
+				// More than two dimensions should be supported, but tested only 2.
+				if ((ranges == 2) && (ranges == multirange->children.size())) {
+					size_t size = 1;
+
+					auto* attr_ranges = new AstNode;
+					attr_ranges->type = AST_CONSTANT;
+
+					for (const auto& itr : multirange->children) {
+						log_assert(itr->type == AST_RANGE);
+						if (itr->children.size() == 2) {
+							const auto width = itr->range_left - itr->range_right + 1;
+							size *= width;
+						} else {
+							const auto width = itr->range_left;
+							size *= width;
+						}
+						attr_ranges->children.push_back(itr->clone());
+					}
+					attr_ranges->range_left  = size - 1;
+					attr_ranges->range_right = 0;
+					attributes[ID::multirange] = attr_ranges;
+
+					// Replace with one-dimensional range (packed vector)
+					AstNode* simple_range = new AstNode(AST_RANGE);
+					simple_range->integer = size;
+					simple_range->children.push_back(mkconst_int(size - 1, false, 32));
+					simple_range->children.push_back(mkconst_int(0, false, 32));
+					simple_range->range_left = size - 1;
+					simple_range->range_right = 0;
+					simple_range->range_valid = true;
+
+					delete children[i];
+					children.erase(children.begin() + i);
+					children.push_back(simple_range);
+
+					is_packed = true;
+					did_something = true;
+				}
+				break;
+			}
+		}
 		log_assert(!is_custom_type);
 	}
 
@@ -1553,6 +1851,9 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 	// annotate wires with their ranges
 	if (type == AST_WIRE) {
 		if (children.size() > 0) {
+			if (!children[0]->range_valid) { // if range is not valid, make sure children is simplify
+				while(children[0]->simplify(true, false, false, stage, -1, -1, false)) {}
+			}
 			if (children[0]->range_valid) {
 				if (!range_valid)
 					did_something = true;
@@ -1609,6 +1910,222 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 		did_something = true;
 	}
 
+	// Access multirange array replaced by registers?
+	if (type == AST_ARGUMENT) {
+		if (children.size() == 1 && children[0]->type == AST_IDENTIFIER) {
+			auto* identifier = children[0];
+			if(identifier->type == AST_IDENTIFIER) {
+				if (identifier->children.size() == 0 && current_scope.count(identifier->str) > 0 && current_scope[identifier->str]->type == AST_MEMORY && current_scope[identifier->str]->children.size() == 2) {
+					identifier->children.push_back(current_scope[identifier->str]->children[1]->clone());
+
+					AstNode *mem = current_scope[identifier->str]; // force mem to be replaced by list of registers, as code below, assumes this
+					AstNode *force_reg = new AstNode(AST_CONSTANT);
+					force_reg->integer = 1;
+					mem->attributes[ID::mem2reg] = force_reg;
+				}
+			}
+			if (identifier->children.size() == 1 && identifier->children[0]->type == AST_RANGE) {
+				auto* range = identifier->children[0];
+				if (range->children.size() == 2 &&
+						range->children[0]->type == AST_CONSTANT &&
+						range->children[1]->type == AST_CONSTANT) {
+					int left = range->children[0]->integer;
+					int right = range->children[1]->integer;
+					if (left > right) {
+						int tmp = left;
+						left = right;
+						right = tmp;
+					}
+
+					if (current_scope.count(identifier->str)) {
+						const auto* reg_node = current_scope.at(identifier->str);
+						const auto ranges = std::count_if(
+							reg_node->children.begin(), reg_node->children.end(),
+							[](const AstNode* node) {
+								return node->type == AST_RANGE;
+							});
+
+						if (ranges == 2) {
+							// FIXME: this assumes that identifier would be replaced by list of registers
+							AstNode* concat = new AstNode;
+							concat->type = AST_CONCAT;
+
+							for (int i = left ; i <= right ; ++i) {
+								AstNode* temp = new AstNode;
+								temp->type = AST_IDENTIFIER;
+								temp->str = identifier->str;
+								temp->children.push_back(new AstNode);
+								temp->children[0]->type = AST_RANGE;
+								temp->children[0]->children.push_back(new AstNode);
+								temp->children[0]->children[0]->type = AST_CONSTANT;
+								temp->children[0]->children[0]->integer = i;
+								concat->children.push_back(temp);
+							}
+
+							// Delete multirange
+							delete children[0];
+							children.clear();
+							// And replace with CONCAT
+							children.push_back(concat);
+
+							did_something = true;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	// Replace multirange acces with vector and range access
+	if (type == AST_IDENTIFIER) {
+		if (current_scope.count(str)) {
+			const auto* temp = current_scope.at(str);
+			log_assert(temp);
+
+			// is this multidimensional array?
+			if (temp->is_packed && temp->attributes.count(ID::multirange)) {
+				const auto* ranges = temp->attributes.at(ID::multirange);
+				log_assert(ranges);
+				log_assert(ranges->type == AST_CONSTANT);
+
+				if (attributes.count(ID::multirange) == 0) {
+					attributes[ID::multirange] = ranges->clone();
+
+					// FIXME: messy, clean this up
+					size_t _offset = 0;
+					size_t _range_left  = ranges->range_left;
+					size_t _range_right = ranges->range_right;
+					size_t _width = _range_left - _range_right + 1;
+
+					const AstNode* multi = nullptr;
+
+					// FIXME: more configurations
+					if (children.size() == 1 && children[0]->type == AST_RANGE) {
+
+						if (children[0]->children[0]->type == AST_IDENTIFIER) {
+							// FIXME: should be merged with below code
+							const auto* id = children[0]->children[0];
+							const auto* r = ranges->children[0]; // r as (orig) Range
+							const size_t r_width = r->range_left - r->range_right + 1;
+							_width /= r_width;
+
+							// for logic [a:b][c] arr;
+							// and arr[d]
+							// generates arr[ ((d*c) + d - 1 : (d*c) ];
+
+							// d * c
+							auto* x2 = new AstNode;
+							x2->type = AST_MUL;
+							x2->children.push_back(id->clone());
+							x2->children.push_back(mkconst_int(_width, false, 32));
+
+							auto *x2_self = new AstNode(AST_SELFSZ, x2);
+
+							auto* x3_add = new AstNode;
+							x3_add->type = AST_ADD;
+							x3_add->children.push_back(x2_self);
+							x3_add->children.push_back(mkconst_int(_width, false, 32));
+
+							// x3 - 1
+							auto* x3 = new AstNode;
+							x3->type = AST_SUB;
+							x3->children.push_back(x3_add);
+							x3->children.push_back(mkconst_int(1, false, 32));
+
+							// d * c
+							auto* x4 = new AstNode;
+							x4->type = AST_MUL;
+							x4->children.push_back(id->clone());
+							x4->children.push_back(mkconst_int(_width, false, 32));
+
+							auto* x4_self = new AstNode(AST_SELFSZ, x4);
+
+							auto *x4_add = new AstNode(AST_ADD, x4_self, mkconst_int(0, false, 32));
+
+							// x3:x4
+							AstNode* simple_range = new AstNode(AST_RANGE);
+							simple_range->children.push_back(x3);
+							simple_range->children.push_back(x4_add);
+							delete children[0];
+							children.erase(children.begin());
+							children.insert(children.begin(), simple_range);
+						} else {
+							// replace with multirange
+							AstNode* temp = new AstNode(AST_MULTIRANGE);
+							temp->children.push_back(children[0]);
+							children[0] = temp;
+
+							multi = children[0];
+							log_assert(multi->children.size() == 1);
+						}
+					} else if (children.size() == 1 && children[0]->type == AST_MULTIRANGE) {
+						multi = children[0];
+					}
+
+					if (multi) {
+						if(multi->children.size() > ranges->children.size())
+						{
+							log_error("Access to not existing element\n");
+						}
+
+						AstNode* simple_range = new AstNode(AST_RANGE);
+						for (size_t idx = 0 ; idx < multi->children.size() ; ++idx) {
+							if (multi->children[0]->children[0]->type != AST_CONSTANT) {
+								AstNode *mul = new AstNode(AST_MUL);
+								mul->children.push_back(multi->children[idx]->children[0]->clone());
+								const auto* r = ranges->children[1]; // r as (orig) Range
+								const size_t r_width = r->range_left - r->range_right + 1;
+								AstNode *width = new AstNode(AST_CONSTANT);
+								width->integer = r_width;
+								mul->children.push_back(width);
+								simple_range->children.push_back(mul);
+							} else {
+								const size_t r_idx = idx;
+
+								const auto* s = multi->children[idx]; // s as Selected range
+
+								const auto* r = ranges->children[r_idx]; // r as (orig) Range
+								const size_t r_width = r->range_left - r->range_right + 1;
+
+								_width /= r_width;
+ 								int start_idx = 0;
+								if (ranges->children[1]->range_swapped) {
+									if (idx == 0) {
+										start_idx = ranges->children[1]->children[1]->integer;
+										_width = r_width;
+										_range_left  = (start_idx - (s->range_left))  * _width + (_width - 1) + _offset;
+										_range_right = (start_idx - (s->range_right)) * _width                + _offset;
+									} else {
+										_range_left  += (s->range_left - ranges->children[0]->range_left);
+										_range_right += (s->range_right - ranges->children[0]->range_right);
+									}
+								} else {
+									_range_left  = ((s->range_left))  * _width + (_width - 1) + _offset;
+									_range_right = ((s->range_right)) * _width                + _offset;
+ 								}
+								_offset = _range_right;
+							}
+						}
+
+						// remove multirange
+						children.erase(children.begin());
+						delete multi;
+
+						// replace with simple (one-dimension) range (packed vector)
+						//log("replaced_range: [%ld:%ld]\n", _range_left, _range_right);
+						//if (_range_left < 0)  _range_left = 0;
+						//if (_range_right < 0) _range_right = 0;
+						if (simple_range->children.size() == 0) {
+							simple_range->children.push_back(mkconst_int(_range_left,  false, 32));
+							simple_range->children.push_back(mkconst_int(_range_right, false, 32));
+						}
+						children.insert(children.begin(), simple_range);
+					}
+				}
+			}
+		}
+	}
+
 	// resolve multiranges on memory access
 	if (type == AST_IDENTIFIER && id2ast && id2ast->type == AST_MEMORY && children.size() > 0 && children[0]->type == AST_MULTIRANGE)
 	{
@@ -1683,13 +2200,61 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 
 	if (type == AST_IDENTIFIER && !basic_prep) {
 		// check if a plausible struct member sss.mmmm
-		std::string sname;
-		if (name_has_dot(str, sname)) {
-			if (current_scope.count(str) > 0) {
-				auto item_node = current_scope[str];
-				if (item_node->type == AST_STRUCT_ITEM) {
+		// check if a plausible struct member sss[srange]
+		// check if a plausible struct member sss[srange].mmmm
+		std::string sname, sfield, srange;
+		if (name_has_dot(str, sname, sfield)) {
+			std::string::size_type pos_start = sname.find("[", 0);
+			std::string::size_type pos_end = sname.rfind("]");
+			std::string look_str = str;
+			int struct_size = 0;
+			int struct_mult = 0;
+			if (pos_start != std::string::npos && pos_end != std::string::npos) {
+				srange = sname.substr(pos_start + 1, pos_end - pos_start - 1);
+				sname = sname.substr(0, pos_start);
+				if (!srange.empty() && std::find_if(srange.begin(), srange.end(), [](unsigned char c) { return !std::isdigit(c); }) == srange.end()) {
+					struct_mult = stoi(srange);
+				} else {
+					for(auto it = current_scope.rbegin(); it != current_scope.rend(); it++) {
+						auto s = *it;
+						// append '\' to srange to make sure we find correct wire
+						if (s.first == "\\" + srange && s.second->children.size() > 0 && s.second->children[0]->integer > 0) {
+							struct_mult = s.second->children[0]->integer;
+							break;
+						}
+					}
+				}
+				look_str = sname + sfield;
+				if (current_scope.count(sname) > 0 && current_scope.count(str) == 0) {
+					auto wire = current_scope[sname];
+					if (wire->attributes.count(ID::wiretype) && current_scope.count(wire->attributes[ID::wiretype]->str)) {
+						const auto *attributes = wire->attributes[ID::wiretype];
+						const auto *wiretype = current_scope[attributes->str];
+						const auto *wiretype_range = wiretype->children[0]->children[0];
+
+						if (attributes->children.size() > 0) {
+							struct_size = wiretype_range->range_left + 1;
+							if(attributes->children[0]->range_swapped) {
+								struct_mult = attributes->children[0]->range_left - struct_mult;
+							}
+						} else {
+							struct_size = wiretype->integer;
+						}
+					}
+				}
+			}
+			if (current_scope.count(look_str) < 1) {
+				look_str = str;
+				sname = str.substr(0, str.rfind("."));
+			}
+			if ((current_scope.count(sname) > 0) && (current_scope[sname]->type == AST_STRUCT_ITEM || current_scope[sname]->type == AST_STRUCT)) {
+				while(current_scope[sname]->simplify(true, false, false, 1, -1, false, false)) { }
+			}
+			if (current_scope.count(look_str) > 0) {
+				auto item_node = current_scope[look_str];
+				if (item_node->type == AST_STRUCT_ITEM || item_node->type == AST_STRUCT) {
 					// structure member, rewrite this node to reference the packed struct wire
-					auto range = make_struct_member_range(this, item_node);
+					auto range = make_struct_member_range(this, item_node, struct_size * struct_mult);
 					newNode = new AstNode(AST_IDENTIFIER, range);
 					newNode->str = sname;
 					newNode->basic_prep = true;
@@ -1698,6 +2263,38 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 					goto apply_newNode;
 				}
 			}
+		} else if (children.size() == 1 && children[0]->type == AST_RANGE) {
+			if (current_scope.count(str) > 0) {
+				while(current_scope[str]->simplify(true, false, false, 1, -1, false, false)) { }
+				if(current_scope[str]->attributes.count(ID::wiretype) && current_scope[str]->type != AST_MEMORY
+						&& current_scope.count(current_scope[str]->attributes[ID::wiretype]->str)
+						&& current_scope[str]->attributes[ID::wiretype]->is_packed)
+				{
+					const auto *attributes = current_scope[str]->attributes[ID::wiretype];
+
+					const auto *wiretype = current_scope[attributes->str];
+					const auto *wiretype_range = wiretype->children[0]->children[0];
+					const auto *current_range = children[0]->children[0];
+					int  element_idx = current_range->integer;
+					const int  size = wiretype_range->range_left + 1;
+
+					if(attributes->children.size() == 1)
+					{
+						const bool range_inversed = attributes->children[0]->range_swapped;
+						if(range_inversed)
+						{
+							element_idx = attributes->children[0]->range_left - element_idx;
+						}
+					}
+					const int upper_bound = size*(element_idx+1)-1;
+					const int lower_bound = size*element_idx;
+
+					auto *range = make_range(upper_bound, lower_bound);
+					delete children[0];
+					children[0] = range;
+					basic_prep = true;
+				}
+			}
 		}
 	}
 	// annotate identifiers using scope resolution and create auto-wires as needed
@@ -1976,19 +2573,28 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 
 			if (buf->type != AST_CONSTANT)
 				log_file_error(filename, location.first_line, "Right hand side of 3rd expression of %s for-loop is not constant (%s)!\n", loop_type_str, type2str(buf->type).c_str());
-
 			delete varbuf->children[0];
 			varbuf->children[0] = buf;
 		}
 
-		if (type == AST_FOR) {
+		if (type == AST_FOR && init_ast->children[0]->id2ast->str.find("$fordecl_block") == std::string::npos) {
 			AstNode *buf = next_ast->clone();
 			delete buf->children[1];
 			buf->children[1] = varbuf->children[0]->clone();
 			current_block->children.insert(current_block->children.begin() + current_block_idx++, buf);
+		} else {
+			// if init was declared in procedular for initialization
+			// we need to remove no longer used wires, that were converted to localparams
+			// and skip assignment to last value of for
+			for(auto it = current_ast_mod->children.begin(); it != current_ast_mod->children.end(); it++) {
+				if ((*it) == init_ast->children[0]->id2ast) {
+					current_ast_mod->children.erase(it);
+				}
+			}
 		}
 
 		current_scope[varbuf->str] = backup_scope_varbuf;
+
 		delete varbuf;
 		delete_children();
 		did_something = true;
@@ -2032,6 +2638,14 @@ bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage,
 		}
 
 		for (size_t i = 0; i < children.size(); i++) {
+			if (children[i]->type == AST_WIRE || children[i]->type == AST_MEMORY || children[i]->type == AST_PARAMETER || children[i]->type == AST_LOCALPARAM || children[i]->type == AST_TYPEDEF || children[i]->type == AST_ENUM) {
+				current_scope[children[i]->str] = children[i];
+				for(auto *c : children[i]->children) {
+					if (c->type == AST_ENUM_ITEM) {
+						current_scope[c->str] = c;
+					}
+				}
+			}
 			children[i]->simplify(const_fold, false, false, stage, -1, false, false);
 			current_ast_mod->children.push_back(children[i]);
 		}
@@ -2568,6 +3182,67 @@ skip_dynamic_range_lvalue_expansion:;
 		}
 	}
 
+	if(children.size() > 0) {
+		for (auto *c : children) {
+			if (c->type == AST_ASSIGN_EQ || c->type == AST_ASSIGN_LE || c->type == AST_ASSIGN) {
+				const auto *lhs = c->children[0];
+				if(lhs->type == AST_IDENTIFIER && lhs->id2ast && lhs->id2ast->type == AST_MEMORY && lhs->children.size() == 0 && lhs->id2ast->children.size() == 2) {
+					AstNode *mem = lhs->id2ast;
+					AstNode *force_reg = new AstNode(AST_CONSTANT);
+					force_reg->integer = 1;
+					mem->attributes[ID::mem2reg] = force_reg; //force mem to be changed to registers
+
+					for (auto *cc : c->children) { //only for a = b
+						if (cc->type == AST_IDENTIFIER) {
+							auto *identifier = cc;
+							AstNode *rangenode = new AstNode(AST_RANGE);
+							AstNode *id = new AstNode(AST_CONSTANT);
+							id->integer = 0;
+							rangenode->children.push_back(id);
+							rangenode->range_left = 0;
+							rangenode->range_right = 0;
+							identifier->children.push_back(rangenode);
+						}
+					}
+					const auto *range = mem->children[1];
+					AstNode *clone = c->clone();
+					auto pos = std::find(children.begin(), children.end(), c); // find position of current node
+					log_assert(pos != children.end());
+					int left = range->range_left;
+					int right = range->range_right;
+					if (left > right) {
+						int tmp = left;
+						left = right;
+						right = tmp;
+					}
+					for (int i = left; i <= right ; ++i) {
+						AstNode *cl;
+						if (i == left)
+							cl = c;
+						else
+							cl = clone->clone();
+						cl->children[0]->children[0]->range_left = i;
+						cl->children[0]->children[0]->range_right = i;
+						cl->children[0]->children[0]->children[0]->integer = i;
+						cl->children[0]->children[0]->range_valid = true;
+						if(cl->children[1]->type == AST_IDENTIFIER) {
+							cl->children[1]->children[0]->range_left = i;
+							cl->children[1]->children[0]->range_right = i;
+							cl->children[1]->children[0]->children[0]->integer = i;
+							cl->children[1]->children[0]->range_valid = true;
+						}
+						else if (cl->children[1]->type == AST_CONCAT) {
+							cl->children[1] = cl->children[1]->children[i];
+						}
+						if (i != left)
+							children.insert(pos, cl);
+					}
+					did_something = true;
+				}
+			}
+		}
+
+	}
 	// assignment with memory in left-hand side expression -> replace with memory write port
 	if (stage > 1 && (type == AST_ASSIGN_EQ || type == AST_ASSIGN_LE) && children[0]->type == AST_IDENTIFIER &&
 			children[0]->id2ast && children[0]->id2ast->type == AST_MEMORY && children[0]->id2ast->children.size() >= 2 &&
@@ -3628,6 +4303,14 @@ replace_fcall_later:;
 							tmp_range_left = (param_width + 2*param_offset) - children[0]->range_right - 1;
 							tmp_range_right = (param_width + 2*param_offset) - children[0]->range_left - 1;
 						}
+
+						if (current_scope[str]->children.size() == 2 && current_scope[str]->children[1]->type == AST_MULTIRANGE && current_scope[str]->children[1]->children[0]->type == AST_RANGE) {
+							AstNode *range = current_scope[str]->children[1]->children[0];
+							int range_access = range->range_left;
+							tmp_range_right *= range_access;
+							tmp_range_left = (tmp_range_left + 1) * range_access;
+
+						}
 						for (int i = tmp_range_right; i <= tmp_range_left; i++) {
 							int index = i - param_offset;
 							if (0 <= index && index < param_width)
@@ -4341,7 +5024,6 @@ bool AstNode::mem2reg_check(pool<AstNode*> &mem2reg_set)
 {
 	if (type != AST_IDENTIFIER || !id2ast || !mem2reg_set.count(id2ast))
 		return false;
-
 	if (children.empty() || children[0]->type != AST_RANGE || GetSize(children[0]->children) != 1)
 		log_file_error(filename, location.first_line, "Invalid array access.\n");
 
diff --git a/frontends/verilog/verilog_parser.y b/frontends/verilog/verilog_parser.y
index 5eb1115ce..a5a6b8937 100644
--- a/frontends/verilog/verilog_parser.y
+++ b/frontends/verilog/verilog_parser.y
@@ -634,7 +634,8 @@ module_arg:
 		ast_stack.back()->children.push_back(astbuf2);
 		delete astbuf1; // really only needed if multiple instances of same type.
 	} module_arg_opt_assignment |
-	attr wire_type range TOK_ID {
+//	attr wire_type range TOK_ID { // use multirange_dimensions or sth...
+	attr wire_type range TOK_ID range {
 		AstNode *node = $2;
 		node->str = *$4;
 		SET_AST_NODE_LOC(node, @4, @4);
@@ -642,6 +643,16 @@ module_arg:
 		AstNode *range = checkRange(node, $3);
 		if (range != NULL)
 			node->children.push_back(range);
+		if ($5 != NULL) {
+			// we should really re-use code from wire_name
+			auto *rangeNode = $5;
+			if (rangeNode->type == AST_RANGE && rangeNode->children.size() == 1) {
+				// SV array size [n], rewrite as [n-1:0]
+				rangeNode->children[0] = new AstNode(AST_SUB, rangeNode->children[0], AstNode::mkconst_int(1, true));
+				rangeNode->children.push_back(AstNode::mkconst_int(0, false));
+			}
+			node->children.push_back(rangeNode);
+		}
 		if (!node->is_input && !node->is_output)
 			frontend_verilog_yyerror("Module port `%s' is neither input nor output.", $4->c_str());
 		if (node->is_reg && node->is_input && !node->is_output && !sv_mode)
@@ -1882,10 +1893,14 @@ struct_var: TOK_ID	{	auto *var_node = astbuf2->clone();
 /////////
 
 wire_decl:
-	attr wire_type range {
+	attr wire_type range_or_multirange {
 		albuf = $1;
 		astbuf1 = $2;
 		astbuf2 = checkRange(astbuf1, $3);
+
+		if (astbuf2 && astbuf2->type == AST_MULTIRANGE) {
+			astbuf2->is_packed = true; // packed multirange
+		}
 	} delay wire_name_list {
 		delete astbuf1;
 		if (astbuf2 != NULL)
diff --git a/kernel/constids.inc b/kernel/constids.inc
index 68d10def6..de05de101 100644
--- a/kernel/constids.inc
+++ b/kernel/constids.inc
@@ -135,6 +135,7 @@ X(OFFSET)
 X(onehot)
 X(P)
 X(parallel_case)
+X(partial)
 X(parameter)
 X(PORTID)
 X(PRIORITY)
@@ -142,6 +143,7 @@ X(PRIORITY_MASK)
 X(Q)
 X(qwp_position)
 X(R)
+X(multirange)
 X(RD_ADDR)
 X(RD_ARST)
 X(RD_ARST_VALUE)
diff --git a/passes/proc/proc_prune.cc b/passes/proc/proc_prune.cc
index 9f1080ef6..bd122b91f 100644
--- a/passes/proc/proc_prune.cc
+++ b/passes/proc/proc_prune.cc
@@ -67,36 +67,51 @@ struct PruneWorker
 		}
 		for (auto it = cs->actions.rbegin(); it != cs->actions.rend(); ) {
 			RTLIL::SigSpec lhs = sigmap(it->first);
-			RTLIL::SigSpec rhs = sigmap(it->second);
-			SigSpec new_lhs, new_rhs;
-			SigSpec conn_lhs, conn_rhs;
-			for (int i = 0; i < GetSize(lhs); i++) {
-				SigBit bit = lhs[i];
+			bool redundant = true;
+			for (auto &bit : lhs) {
 				if (bit.wire && !assigned[bit]) {
-					if (!affected[bit] && root) {
-						conn_lhs.append(bit);
-						conn_rhs.append(rhs[i]);
-					} else {
-						new_lhs.append(bit);
-						new_rhs.append(rhs[i]);
-					}
-					assigned.insert(bit);
-					affected.insert(bit);
+					redundant = false;
+					break;
 				}
 			}
-			if (GetSize(conn_lhs)) {
-				promoted_count++;
-				module->connect(conn_lhs, conn_rhs);
-			}
-			if (GetSize(new_lhs) == 0) {
-				if (GetSize(conn_lhs) == 0)
-					removed_count++;
-				cs->actions.erase((it++).base() - 1);
+			bool remove = false;
+			if (redundant) {
+				removed_count++;
+				remove = true;
 			} else {
-				it->first = new_lhs;
-				it->second = new_rhs;
-				it++;
+				if (root) {
+					bool promotable = true;
+					for (auto &bit : lhs) {
+						if (bit.wire && affected[bit] && !assigned[bit]) {
+							promotable = false;
+							break;
+						}
+					}
+					if (promotable) {
+						RTLIL::SigSpec rhs = sigmap(it->second);
+						RTLIL::SigSig conn;
+						for (int i = 0; i < GetSize(lhs); i++) {
+							RTLIL::SigBit lhs_bit = lhs[i];
+							if (lhs_bit.wire && !assigned[lhs_bit]) {
+								conn.first.append(lhs_bit);
+								conn.second.append(rhs.extract(i));
+							}
+						}
+						promoted_count++;
+						module->connect(conn);
+						remove = true;
+					}
+				}
+				for (auto &bit : lhs)
+					if (bit.wire)
+						assigned.insert(bit);
+				for (auto &bit : lhs)
+					if (bit.wire)
+						affected.insert(bit);
 			}
+			if (remove)
+				cs->actions.erase((it++).base() - 1);
+			else it++;
 		}
 		return assigned;
 	}
diff --git a/tests/proc/bug2962.ys b/tests/proc/bug2962.ys
deleted file mode 100644
index 99da8db5d..000000000
--- a/tests/proc/bug2962.ys
+++ /dev/null
@@ -1,22 +0,0 @@
-read_ilang << EOT
-module \top
-   wire width 4 input 1 \a
-   wire width 2 input 2 \b
-   wire input 3 \clk
-   wire width 4 output 4 \q
-   wire input 5 \en
-   wire width 4 \nq
-   process \p
-     assign \nq \a
-     assign \nq [1:0] \b
-     switch \en
-       case 1'1
-         assign \nq [3] 1'0
-     end
-     sync posedge \clk
-       update \q \nq
-   end
-end
-EOT
-proc
-check -assert
